# Итерируемые объекты

В языке Python под **итерируемым объектом** подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом. К примеру, уже известные нам списки (тип `list`), строки (тип `str`), кортежи (тип `tuple`), множества (тип `set`), словари (тип `dict`) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.

Приведенный ниже код:

```python
numbers = [1, 2, 3]
name = 'python'

for num in numbers:        # итерируем по списку, перебирая каждый элемент
    print(num)

for c in name:             # итерируем по строке, перебирая каждый символ
    print(c)

print(2 in numbers)        # неявное итерирование по списку
print('A' in name)         # неявное итерирование по строке
print(*numbers)   
```


**Если подходить более формально в Python, существует два типа итерируемых объектов:**

1. _итераторы_
2. _коллекции и последовательности_

# Итераторы

**Итератор** — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию `next()`, то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к возникновению исключения `StopIteration`.

Для того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию `iter()`, передав нужную коллекцию в качестве ее аргумента.

Например, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до последнего.

Приведенный ниже код:

```python
numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основании списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора
```

выводит:

```no-highlight
1
2
3
```

После того как мы получили итератор, мы можем передать его встроенной функции `next()`. При каждом новом вызове, функция `next()` возвращает очередной элемент итератора. Если же в итераторе элементов больше не осталось, то функция `next()` возбуждает исключение `StopIteration`.

Приведенный ниже код:

```python
numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основе списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора

print(next(iterator))             # возбуждается исключение StopIteration
```

приводит к возникновению исключения `StopIteration`.

# Преимущества итераторов

Основными преимуществами использования итераторов являются:

- однотипность работы с объектами разных типов
- ленивые вычисления и экономия потребляемой памяти
- комбинация множества итераторов для создания понятной и читабельной программы


## Ленивые вычисления и экономия потребляемой памяти

Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время на вычисление.

```python
numbers = range(5)             # 5 чисел в последовательности

for num in numbers:
    print(num)
```

Объекты типа `range` являются итерируемыми объектами. Цикл `for` создает на основе объекта `range` итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число 44.

Важно понимать, что объект типа `range` не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся. Размер объектов `range` не зависит от количества чисел, которые предполагается перебрать, ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение.

Приведенный ниже код:

```python
from sys import getsizeof

numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(getsizeof(numbers1))
print(getsizeof(numbers2))
print(getsizeof(numbers3))
```

выводит (размер в байтах):

```no-highlight
48
48
48
```

Все объекты `range` имеют один и тот же размер в памяти — 4848 байт. Такой подход позволяет создавать "большие" итераторы (даже бесконечные), не занимая много памяти.

Заметим, что мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.

## Комбинация множества итераторов

У итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом.

Приведенный ниже код:

```python
sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
```

выводит:

```no-highlight
1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
```


