## Генераторы списков
Список можно генерировать в одну строку
Синтаксис:

```python
[<способ формирования значения> for <переменная> in <итерируемый объект>]
```

Пример:

```python
a = [x ** 2 for x in range(1, 6)]
print(a) # выведет [1, 4, 9, 16, 25]
a = [2 for i in range(5)] # [2, 2, 2, 2, 2] тоже самое, что a = [1] * 6
a = [0.5 * i for i in range(6)] # [0.0, 0.5, 1.0, 1.5, 2.0, 2.5]
```

Многострочные генераторы списков:

```python
cities = [
    int(i) for i in input().split()
    if int(i) % 2 == 0
]
print(*cities) # в списке будут только четные значения, например от ввода 1 2 3 4 5 6 останется только 2 4 6
```
Также в генераторах можно задавать условия
Синтаксис:

```python
[<способ формирования значения> for <переменная> in <итерируемый объект> <условие>]
```

Пример:

```python
a = [i for i in range(-5, 5) if i < 0]
print(a) # выведет [-5, -4, -3, -2, -1]
```

## Вложенные генераторы
Генераторы можно вложить друг в друга:

```python
a = [(i, j)
    for i in range(4)
    for j in range(4)
    ]
print(a)
a = [(i, j) for i in range(4) for j in range(4)]
[print(*i) for i in a]
```

```python
a = [f"{i}*{j}={i*j}"
    for i in range(2, 6)
    for j in range(2, 6)
    ]
[print(*i) for i in a] # выведет часть таблицы умножения
#2 * 2 = 4
#2 * 3 = 6
#2 * 4 = 8
#2 * 5 = 1 0
#3 * 2 = 6
#3 * 3 = 9
#3 * 4 = 1 2
#3 * 5 = 1 5
#4 * 2 = 8
#4 * 3 = 1 2
#4 * 4 = 1 6
#4 * 5 = 2 0
#5 * 2 = 1 0
#5 * 3 = 1 5
#5 * 4 = 2 0
#5 * 5 = 2 5
```

## Генераторы 

Существует еще более простой, чем генераторные функции, содержащие оператор `yield`, способ создания итераторов – **генераторные выражения**. Они подходят, когда код тела генераторной функции можно записать в одно выражение.

**Генератора кортежей не существует**

```python
a = (i for i in range(5))
print(*a) # 0 1 2 3 4
```

Приведенный ниже код:

```python
from sys import getsizeof

numbers = [1, 9, 8, 7, 90, -56, -34, 56, 100, 90, 2, 8]

even_numbers = (num for num in numbers if num % 2 == 0)         # используем круглые скобки

print(type(even_numbers))
print(even_numbers)
print(getsizeof(even_numbers))
```

выводит:

```no-highlight
<class 'generator'>
<generator object <genexpr> at 0x0000020E9C767300>
104
```

## Функции генераторы

Функция генератор – это функция, которая возвращает итератор. Она выглядит как обычная функция, за исключением того, что использует выражение yield, а не return.

Функция генератор, напротив, сохраняет локальные переменные от вызова к вызову. Это своего рода возобновляемая функция.


Рассмотрим пример функции генератора, которая порождает последовательность целых чисел от 
0 (включительно) до n (не включительно).

```python
def generate_ints(n):
    for num in range(n):
        yield num
```

Приведенный ниже код:

```python
generator1 = generate_ints(5)           # создаем генератор, порождающий числа 0 1 2 3 4

print(type(generator1))

print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))

generator2 = generate_ints(3)           # создаем генератор, порождающий числа 0 1 2

for num in generator2:
    print(num)

num1, num2 = generate_ints(2)           # создаем генератор, порождающий числа 0 1

print(num1, num2)
```

выводит:

```
<class 'generator'>
0
1
2
3
4
0
1
2
0 1
```

## Функции генераторы с побочными действиями

Функция генератор может не только порождать значения, но и совершать различные побочные действия во время выполнения, такие как:

- вывод текста на экран
- запись данных в файл
- приостановка исполняющейся программы на некоторое время
и т.д.
- Рассмотрим определение функции генератора, которая печатает текст во время выполнения.

Приведенный ниже код:

```python
def generate_AB():
    print('start')
    yield 'A'
    print('continue')
    yield 'B'
    print('end')

for char in generate_AB():
    print('-->', char)
```

выводит:

```no-highlight
start
--> A
continue
--> B
end
```

## Конструкция yield from

Генераторную функцию можно упростить, если использовать синтаксическую конструкцию `yield from <iterable>`, которая появилась в Python 3.3.

Приведенный ниже код равнозначен первому определению генераторной функции `get_data()`:

```python
def get_data():
    yield from range(5)
    yield from 'ABC'
```

Таким образом, синтаксическая конструкция `yield from <iterable>` позволяет объединить две конструкции: `yield` и цикл `for`.

Реализуем генераторную функцию chain(*iterables), которая принимает произвольное количество итерируемых объектов и возвращает генератор, который последовательно порождает все значения сначала первого итерируемого объекта, затем второго, третьего и т.д.

Приведенный ниже код:

```python
def chain(*iterables):
    for it in iterables:
        for value in it:
            yield value

for i in chain('AB', [1, 2], (4, 5), {'name': 'Timur', 'age': 29}):
    print(i, end=' ')
```

выводит:

```bash
A B 1 2 4 5 name age 
```


С помощью конструкции `yield from iterable` мы можем упростить тело генераторной функцииchain():

```python

def chain(*iterables):
    for it in iterables:
        yield from it	
```

Как мы видим, конструкция yield from полностью заменяет внутренний цикл for и код действительно смотрится несколько проще.


Объединение конструкции `yield` и цикла `for` лишь часть возможностей `yield from`. На самом деле конструкция `yield from` позволяет вкладывать один генератор в другой, таким образом создавать субгенераторы (вложенные генераторы).

Приведенный ниже код:

```python
def generator2():
    yield 'Red'
    yield 'Blue'

def generator1():
    yield 'Green'
    yield from generator2()            # запрашиваем значение из субгенератора
    yield 'Yellow'
    yield 'Black'

for color in generator1():
    print(color, end=' ')
```

выводит:

```no-highlight
Green Red Blue Yellow Black 
```

## Рекурсивные функции генераторы

Конструкции `yield` и `yield from` можно использовать для написания рекурсивных генераторов.

Приведенный ниже код:

```python
def numbers(start):
    if not isinstance(start, int):
        raise TypeError('Аргументом должно быть целое число')
    yield start
    yield from numbers(start + 1)
```

определяет бесконечный генератор `numbers(start)`, который порождает все целые числа со значения `start`.

Приведенный ниже код:

```python
for index, number in enumerate(numbers(3)):
    if index > 5:
        break
    print(number)
```

выводит:

```no-highlight
3
4
5
6
7
8
```

## Конвейеры генераторов

Как мы уже знаем, у итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом. К примеру, мы часто использовали встроенные функции `filter()` и `map()`, для того чтобы сначала отфильтровать данные, а затем их преобразовать.

Приведенный ниже код:

```python
def integers(n):
    for i in range(1, n + 1):
        yield i

def evens(iterable):
    for i in iterable:
        if not i % 2:
            yield i

def squared(iterable):
    for i in iterable:
        yield i * i

def negated(iterable):
    for i in iterable:
        yield -i

chain = negated(squared(evens(integers(10))))

print(*chain)
```

выводит:

```no-highlight
-4 -16 -36 -64 -100
```

Конвейеры данных выглядят еще нагляднее, если они построены на основе генераторных выражений.

Приведенный ниже код:

```python
n = 10

integers = (i for i in range(1, n + 1))
evens = (i for i in integers if not i % 2)
squared = (i * i for i in evens)
negated = (-i for i in squared)

print(*negated)
```

полностью аналогичен примеру выше.


