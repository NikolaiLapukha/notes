Вместо повторения кода , можно перенести  его в отдельную **функцию**  и вызвать ее n раз.

Для создания функции пишем такой код:

```python
def draw_box():
    for _ in range(5):
        print('*' * 7)
```

Когда функция создана, чтобы увидеть результат ее работы, надо вызвать ее по имени:

```python
draw_box()
```

## Именование функций

Имена функциям назначаются точно так же, как переменным. Имя функции должно быть достаточно описательным, чтобы любой читающий ваш код, мог догадаться, что именно делает функция.

Python и тут требует соблюдения тех же правил, что при именовании переменных:

1. в имени функции используются только латинские буквы a-z, A-Z, цифры и символ нижнего подчеркивания (_);
    
2. имя функции не может начинаться с цифры;
    
3. имя функции по возможности должно отражать ее назначение;
    
4. символы верхнего и нижнего регистра различаются.

Поскольку функции **выполняют действия**, большинство программистов предпочитает в именах функций **использовать** **глаголы**. Например:

- функцию, которая **рисует прямоугольник**, можно назвать `draw_box()`;
- функцию, которая **печатает чек**, можно назвать `print_check()`;
- функцию, которая вычисляет заработную плату до удержаний, можно назвать `calculate_gross_рау()`. 

Каждое из этих имен дает описание того, что функция делает.

## Объявление функции

Итак, функция – отдельная, функционально независимая часть программы, выполняющая определенную задачу.

Функции объявляются с помощью ключевого слова `def` (от англ. define – определять). За ключевым словом `def` следуют название функции, круглые скобки `()` и двоеточие `:`.

```python
def название_функции():
    блок кода
```

Рассмотрим объявление функции:

```python
def print_message():
    print('Я - Артур,')
    print('король британцев. ')
```

Этот фрагмент кода определяет функцию с именем `print_message()`. Тело ее состоит из двух инструкций, и вызов приведет к их исполнению.

## Вызов функции

Для вызова функции пишут ее название и круглые скобки.

```python
# объявление функции
def print_message():
    print('Я - Артур,')
    print('король британцев. ')


# вызов функции
print_message()
```

## Функции с параметрами

Функции могут принимать входные параметры, что делает их более гибкими.

Функции с параметрами объявляются так же как функции без параметров, только с указанием в скобках:

```python
def название_функции(параметры):
    блок кода
```

Давайте перепишем предыдущую версию функции `draw_box()` так, чтобы она принимала параметры, задающие высоту и ширину прямоугольника:

```python
def draw_box(height, width):    # функция принимает два параметра
    for i in range(height):
        print('*' * width)
```

Чтобы вывести звездный прямоугольник размерами 5 на 7 мы пишем код:

```python
draw_box(5, 7)
```

## Локальные переменные

**Локальными** называются переменные, объявленные внутри функции и доступные только ей самой. Программный код за пределами функции к ним доступа не имеет.

Рассмотрим функцию `print_texas()`, которая выводит информацию о количестве птиц, обитающих в Техасе.

```python
def print_texas():
    birds = 5000
    print('В Техасе обитает', birds, 'птиц.')
```

В теле функции мы создаем переменную `birds`, которой присваивается значение, равное 5000. Такая переменная является локальной для функции `print_texas()`. Всякий раз, когда переменной внутри функции присваивается значение, в результате создается локальная переменная. Она принадлежит функции, в которой создается,  и к ней получает доступ только программный код этой функции.

Если программный код одной функции попытается обратиться к локальной переменной, принадлежащей другой функции, произойдет ошибка.

Рассмотрим следующий программный код:

```python
def print_texas():
    birds = 5000
    print('В Техасе обитает', birds, 'птиц.')

def print_california():
    print('В Калифорнии обитает', birds, 'птиц.')
```

Функция print_california() обращается к локальной переменной birds функции print_texas(). Вызов функции print_california(), приводит к ошибке:

```
NameError: name 'birds' is not defined
```

Локальные переменные скрыты от других функций, поэтому другие функции могут иметь собственные локальные переменные с тем же именем. Например:

```python
def print_texas():
    birds = 5000
    print('В Техасе обитает', birds, 'птиц.')

def print_california():
    birds = 9000
    print('В Калифорнии обитает', birds, 'птиц.')
```

В каждой из этих двух функций есть локальная переменная с именем birds. Но они никогда не видны одновременно, так как находятся в разных функциях.

## Глобальные переменные

Глобальными называются переменные, объявленные в основной программе и доступные как программе, так и всем ее функциям.

Рассмотрим следующий программный код: 

```python
birds = 5000    # глобальная переменная

def print_texas():
    print('В Техасе обитает', birds, 'птиц.')

def print_california():
    print('В Калифорнии обитает', birds, 'птиц.')
```

Функция может использовать любые глобальные переменные кроме имеющих те же имена, что и ее локальные переменные. Если в функции объявлена локальная переменная с тем же именем, что у одной из глобальных, то данная глобальная переменная становится недоступной в этой функции, и при указании идентификатора переменной произойдет обращение к локальной переменной функции, а не одноименной глобальной.

Рассмотрим следующий программный код:

```python
birds = 5000   # глобальная переменная

def print_texas():
    birds = 1000  # локальная переменная
    print('В Техасе обитает', birds, 'птиц.')

def print_california():
    birds = 7000  # локальная переменная
    print('В Калифорнии обитает', birds, 'птиц.')
```

В самом начале программы мы создаем глобальную переменную birds, значение которой равно 5000. Далее мы описываем две функции, в которых создаются локальные переменные с таким же именем birds. Таким образом при обращении к переменной birds внутри функций будет происходить обращение именно к локальной переменной.

Результатом выполнения следующего кода:

```python
print_texas()
print_california()
```

будет:

```
В Техасе обитает 1000 птиц.
В Калифорнии обитает 7000 птиц.
```

>[! attention] Примечание
>Большинство программистов согласны, что **следует ограничить использование глобальных переменных либо не использовать их вообще.** 
>Причины следующие:
>Глобальные переменные затрудняют отладку программы. Значение глобальной переменной может быть изменено любой инструкцией в программном файле. Если обнаружится, что в глобальной переменной хранится неверное значение, то придется отыскать все инструкции, которые к ней обращаются, чтобы определить, откуда поступает плохое значение. В программе с тысячами строк кода сделать это непросто.
Функции, использующие глобальные переменные, обычно зависят от этих переменных. Если возникнет необходимость применить такую функцию в другой программе, скорее всего придется эту функцию перепроектировать, чтобы она не опиралась на глобальную переменную.
Глобальные переменные затрудняют понимание программы. Глобальная переменная может быть модифицирована любой инструкцией в программе. При необходимости разобраться в какой-то части программы, использующей глобальную переменную, придется узнать обо всех других частях программы, обращающихся к этой глобальной переменной.

## Глобальные константы

Хотя следует избегать использования глобальных переменных, в программе допускается применение глобальных констант. Глобальная константа – глобальное имя, ссылающееся на неизменное значение. Поскольку значение глобальной константы не может быть изменено во время исполнения программы, можно не беспокоиться о потенциальных опасностях, обычно связанных с использованием глобальных переменных.

Несмотря на то, что язык Python не позволяет создавать настоящие глобальные константы, их можно имитировать при помощи глобальных переменных. Если глобальная переменная не объявляется с использованием ключевого слова global внутри функции, то внутри этой функции вы никак не сможете изменить значение этой глобальной переменной. 

### Ключевое слово global

Если нужно, чтобы инструкция внутри функции присваивала значение глобальной переменной, то требуется дополнительный шаг. В этом случае, глобальная переменная должна быть объявлена внутри функции.

Рассмотрим следующий программный код:

```python
def print_texas():
    global birds
    birds = 5000
    print('В Техасе обитает', birds, 'птиц.')

def print_california():
    print('В Калифорнии обитает', birds, 'птиц.')

print_texas()
print_california()
```


## Функция с возвратом значения
Функция с возвратом значения похожа на функцию без возврата значения тем, что:

это набор инструкций, выполняющий определенную задачу;
когда нужно выполнить функцию, ее вызывают.
Однако, когда функция с возвратом значения завершается, она возвращает значение в ту часть программы, которая ее вызвала. Возвращаемое из функции значение используется как любое другое: оно может быть присвоено переменной, выведено на экран, использовано в математическом выражении (если это число) и т. д.
Функцию с возвратом значения пишут точно так же, как и без, но она должна иметь инструкцию return.

Вот общий формат определения функции с возвратом значения в Python:

```python
def название_функции():
    блок кода
    return выражение
```

В функции должна быть инструкция return, принимающая форму:

```
return выражение
```

При изучении вещественных чисел мы решали задачу о переводе градусов по шкале Фаренгейта в градусы по шкале Цельсия по формуле 𝐶=5/9 * (𝐹− 32).

Напишем функцию, которая осуществляет перевод:

```python
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result
```

Задача этой функции — принять одно число temp в качестве аргумента – количество градусов по шкале Фаренгейта, и вернуть другое — количество градусов по шкале Цельсия.

### Использование инструкции return по максимуму

Взглянем еще раз на функцию `convert_to_celsius()`:

```python
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result
```

Поскольку инструкция return возвращает значение выражения, переменную result устраняем и переписываем функцию так:

```python
def convert_to_celsius(temp):
    return (5 / 9) * (temp - 32)
```

Эта версия функции не сохраняет значение (5 / 9) * (temp - 32) в отдельной переменной, а сразу возвращает значение выражения с помощью инструкции return. Делает то же, что и предыдущая версия, но за один шаг.

### Использование нескольких return

В одной функции может быть сколько угодно инструкций return. Рассмотрим функцию convert_grade(), которая переводит стобалльную оценку в пятибалльную:

```python
def convert_grade(grade):
    if grade >= 90:
        return 5
    elif grade >= 80:
        return 4
    elif grade >= 70: 
        return 3
    elif grade >= 60:
        return 2
    else:
        return 1

# основная программа
grade = int(input('Введите вашу отметку по 100-балльной системе: '))
print(convert_grade(grade))
```

Функцию convert_grade() можно переписать с помощью одной инструкции return:

```python
def convert_grade(grade):
    if grade >= 90:
        result = 5
    elif grade >= 80:
        result = 4
    elif grade >= 70: 
        result = 3
    elif grade >= 60:
        result = 2
    else:
        result = 1
    
    return result
```





## Примеры программ
