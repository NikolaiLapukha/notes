
## Базовый синтаксис

```python
class <Название класса>: # Определение класса
	def __init__(self): #Конструктор
        pass
```


Примеры:

```python
class Cat():
    def __init__(self, name, age, isHappy): # конструктор
        self.name = name
        self.age = age
        self.isHappy = isHappy

	def getData(self): # метод класса
        return f"Имя: {self.name}, возраст: {self.age}, счаслив ли: {self.isHappy}"
  
catLiova = Cat('Liova', 1.1, True)
```


## Функции атрибутов классов

### `getattr` - Возвращает значение атрибута объекта

```python
class Point():
    color = 'red'
    radius = 2

a = Point()
a.color = 'red'
print(getattr(Point, 'color')) # red
print(getattr(Point, 'perimetr')) # ошибка
print(getattr(Point, 'perimetr', False)) # False
```

### `hasattr` - Проверяет на наличие атрибута в объекте 

```python
print(hasattr(Point, 'color')) # True
```

### `setattr` - Задает значение атрибута, если атрибута нет, то создает его

```python
setattr(Point, 'x',  2)
print(Point.x) # 2
```

```python
file = {'name': 'Alex', 'age': 18, 'hobby': 'films'}

class Person:
    pass

id_1 = Person()

for key, value in file.items():
    setattr(id_1, key, value)      # используем цикл по file и создаём атрибуты в id_1
    # id_1.key = value             # через точку так не получится

print(id_1.hobby)  # films
```

### `delattr` - Удаляет атрибут с заданным именем 

```python
delattr(Point, 'x')
print(Point.x) # AttributeError: type object 'Point' has no attribute 'x'
```

### `__doc__` - Возвращает строку с описанием класса

```python
class Point():
    'Класс определяет объект точки'
    color = 'red'
    radius = 2

a = Point()
print(Point.__doc__) # Класс определяет объект точки
```

### `__dict__` - Содержит набор атрибутов экземпляра класса

Существует `__dict__` экземпляра и `__dict__` класса, то есть это два разных хранилища. Атрибут `__dict__` экземпляра является _словарём_ и хранит _только атрибуты экземпляра_. Атрибут `__dict__` класса похож на словарь, но имеет некоторые ограничения, он хранит _только те атрибуты и методы, которые были определены (созданы) в классе_, а также другую информацию о классе. 

```python
print(Point.__dict__) # {'__module__': '__main__', '__doc__': 'Класс определяет объект точки', 'color': 'red', 'radius': 2, '__dict__': <attribute '__dict__' of 'Point' objects>, '__weakref__': <attribute '__weakref__' of 'Point' objects>}
```

## Методы класса

```python
class Point():
    'Класс определяет объект точки'
    color = 'red'
    radius = 2

    def doSome(self): # метод класса
        print('Метод класса')
        
    def setCoords(self, x, y): # метод класса
        self.x = x
        self.y = y

    def getCoors(self): # метод класса
        return(self.x, self.y)

	
a = Point()
a.doSome() # Метод класса

a.setCoords(2, 1)
print(a.getCoors()) # (2, 1)
```

## Инициализатор и финализатор

Инициализатор используется для автоматического создания атрибутов экземпляра класса при создании этого экземпляра. Или для автоматического выполнения каких-то действий при создании экземпляра класса.

Синтаксис:

```python
def __init__(self): # инициализотор он же конструктор
        
```

Пример:

```python
class Point():
    'Класс определяет объект точки'
    color = 'red'
    radius = 2
    def __init__(self, x, y): # инициализотор он же конструктор
        self.x = x
        self.y = y

    def getCoors(self):
        return(self.x, self.y)

a = Point(2, 3)
print(a.getCoors()) # (2, 3)
```

Финализатор используется для автоматического выполнения каких-то действий при удалении экзепляпа класса.

Синтаксис:

```python
def __del__(self): # Финализатор
```

Пример:

```python
    def __del__(self):
        print(f"remove object {self}")
# remove object <__main__.Point object at 0x7d73765a2bd0>
```

## `@classmethod` - Для манипуляций с атрибутами класса

```python
class Seasons:
    seasons = ['весна', 'лето', 'зима', 'осень']

    def __init__(self, season):
        self.season = season if self.season_check(season) \
            else 'Неизвестно'

    @classmethod
    def season_check(cls, season):
        return season.lower() in cls.seasons


print(Seasons.season_check('Весна'))
```
## `@staticmethod` - метод, не контактирующий с атрибутами класса и экземплярами, т.е. абсолютно независимый, но уместный т.к. соответствует тематике класса. 

```python
from random import choice as ch


class Seasons:
    seasons = ['весна', 'лето', 'зима', 'осень']

    def __init__(self, season):
        self.season = season if self.season_check(season) \
            else 'Неизвестно'

    @classmethod
    def season_check(cls, season):
        return season.lower() in cls.seasons

    @staticmethod
    def rand_fact():
        lst = ['Весна! Бабушки сбились в стаю на лавочке.',
               'Летом буду скидывать кожу как удав.',
               'Осенью деревья ржавеют.',
               'Зимой впаду вспячку.']
        return ch(lst)

print(Seasons.rand_fact())
```

## Инкапсуляция

*Инкапсуляция - процесс скрытия реализации некоторых деталей логики класса от внешних запросов*

Все методы и атрибуты изначально имеют публичный статус доступа. Чтобы ограничить их использование извне, перед такими методами или атрибутами прописывают нижнее подчеркивание, в таком случае режим доступа меняется на защищенный:

```python
class Windows:
    def __init__(self, name, key):
        self._name = name
        self._key = key


win = Windows('Windows 11 Professional', 'w4g4-f4b3-wd32-c45n')
print(win._name, win._key)
```

Если нужен более серьёзный уровень защиты, то можно использовать приватный уровень доступа. Для этого необходимо в начале имени переменной использовать двойное нижнее подчеркивание:

```python
class Spy:
    passphrase = 'ты пчела я пчеловод'
    data = 'секретные данные'

    @classmethod
    def __get_data(cls):
        return cls.data

    def get_secret_information(self, psw):
        if psw == self.passphrase:
            return self.__get_data()
        raise TypeError('Фраза неверна!')


spy = Spy()
print(spy.get_secret_information('ты пчела я пчеловод'))
```

raise - инструкция, позволяющая вызвать исключение.

## Property

`property` - класс декоратор для определения сеттера, геттера, делиттер.

```python
class Container:
    def __init__(self):
        self.__content = []

    def get_content(self):
        return self.__content

    def set_content(self, item):
        self.__content = item

    def del_content(self):
        del self.__content

    content = property(fget=get_content, fset=set_content, fdel=del_content)


cont = Container()
print(cont.content)
cont.content = ['вафли', 'крыжовник', 'казинаки']
print(cont.content)
del cont.content
print(cont.__dict__)
```

```python
class Container:
    def __init__(self):
        self.__content = []

    @property
    def content(self):
        return self.__content

    @content.setter
    def content(self, item):
        if 'хурьма' in item:
            raise TypeError('Хурьма категорически не надо!!!')
        self.__content = item

    @content.deleter
    def content(self):
        del self.__content


cont = Container()
print(cont.content)
cont.content = ['огурчики', 'киселёк']
print(cont.content)
```

## Дескрипторы

```python
class Descr:
    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value


class Capybara:
    age = Descr()
    color = Descr()

    def __init__(self, age, color='каштановый'):
        self.age = age
        self.color = color
```

## Наследование и полиморфизм

В Python наследование является одним из основных принципов объектно-ориентированного программирования. Оно позволяет создавать новые классы, называемые *дочерними* классами (*подклассами*), на основе уже существующих классов, называемых *родительскими* классами (*суперклассами, базовыми классами*). Для ясности будем использовать термины родительский и дочерний класс.
### Создание дочернего класса

```python
class Transport:        # Родительский класс
    pass        

class Car(Transport):   # Дочерний класс
    pass
```

### Наследование родительского класса

Когда мы объявляем дочерний класс, он наследуется от родительского класса и получает возможность обращаться к атрибутам и методам родительского класса.

```python
class Transport:           # Родительский класс
    name = 'car'
    def get_name(self):
        return self.name
 
class Car(Transport):      # Дочерний класс
    pass

toyota = Car()
print(toyota.name, toyota.get_name()) # car car
print(Car.name)  # car
```

Дочерний класс может пользоваться всем, что есть в родительском классе, если это не вызовет ошибки. Например класс `Car` может обратиться к `get_name()`, но это вызовет ошибку, потому что `get_name()` - это обычный метод, который вызывается экземпляром, а не классом. Но если бы `get_name()` был "методом класса" (вспомните @classmethod), то ошибки бы не возникло.

### Функции super()

Функция `super()`используется в основном для вызова методов родительского класса из методов дочернего класса. Вы же помните, что к обычным методам нельзя обратиться через класс. Но функция `super()` использует особый объект, который позволяет обращаться к методам родительского класса.

```python
class Cat:
    def hello_cat(self):
        self.name = 'hello cat'

class Dog(Cat):
    def hello_dog(self):
        super().hello_cat()
        


test = Dog()
test.hello_dog()     # вызвали метод дочернего класса hello_dog
print(test.name)     # hello cat
```

### Множественное наследование

Множественное наследование используется редко, но в определённых ситуациях оно конечно же используется. Множественное наследование в Python позволяет классу наследовать свойства и методы нескольких родительских классов. Это означает, что класс может наследовать функциональность от нескольких классов одновременно.

```python
class A:
    def method1(self):
        print("Method 1 from A")

class B:
    def method2(self):
        print("Method 2 from B")

class C(A, B):
    def method3(self):
        print("Method 3 from C")

child = C()

child.method1()  # Вывод: "Method 1 from A"
child.method2()  # Вывод: "Method 2 from B"
child.method3()  # Вывод: "Method 3 from C"
```

## Магические методы

### `__New__()` - Магический метод для автоматического выполнения чего либо перед созданием объекта класса

```python
class Point:
    def __new__(cls, *args, **kwargs):
        print('Вызов метода для __new__ ' + str(cls))
        return super().__new__(cls)


    def __init__(self, x=0, y=0):
        print('Вызов __init__ для ' + str(self))
        self.x = x
        self.y = y


p1 = Point()

#Вызов метода для __new__ <class '__main__.Point'>
#Вызов __init__ для <__main__.Point object at 0x77180b136900>
```

### __getattribute__

Скорее всего вы не знали, но каждый раз когда мы вызываем атрибут через точку, активируется метод __getattribute__ и возвращает нам значение этого атрибута. Метод __getattribute__ вызывается независимо от того, существует атрибут или нет. Получается, что __getattribute__ - это метод, который позволяет получить значение атрибута объекта по его имени.

**Синтаксис**
По умолчанию __getattribute__ выглядит так:

```python
def __getattribute__(self, item):
    return object.__getattribute__(self, item)  # возвращает значение атрибута
```

- self - это **экземпляр класса**, для которого вызывается метод.
- item - это **имя атрибута**, к которому происходит обращение.

### __getattr__

Метод __getattr__ предоставляет возможность определить поведение при обращении к несуществующим атрибутам объекта. Он позволяет программисту контролировать, что происходит при попытке доступа к неизвестным атрибутам и предоставлять альтернативное поведение или возвращать значение по умолчанию.

Синтаксис

```python
def __getattr__(self, item):
    # код, определяющий поведение при обращении к несуществующему атрибуту
```

- self - ссылка на сам объект.
- item - имя атрибута, к которому происходит обращение.

```python
class Person:
    def __getattr__(self, item):
        return f"Атрибут {item} не найден"

person = Person()
print(person.age)  # Вывод: Атрибут age не найден
```

