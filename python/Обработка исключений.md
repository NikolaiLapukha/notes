`try` - ключевое слово для блока кода в котором может возникнуть исключение
`except` - ключевое слово для обработки самого исключения

```python
try:
    file = open('file2.txt') # такого файла нет, возникнет исключение
    print(file.readlines())
    file.close()
except FileNotFoundError: # обработка исключения
    print('Файл не найден!')
```

`finally` - ключевое слово для выполнения блока кода в любом случае независимо от того было ли исключение или нет.

```python
try:
    file = open('file.txt') # файл есть, исключения нет
    try:
        r = file.read()
        int(r) # ошибка чтения
        print(r)
    finally: # выполняется в любом случае
        file.close()
except FileNotFoundError:
    print('Файл не найден')
except: # обработка вложенного исключения
    print('Ошибка при чтении файла') # выведет в консоль
```

`with` - обрабатывает исключение и автоматически закрывает файл

```python
try:
    with open('file.txt') as file:
        r = file.read()
        int(r)
        print(r)
except:
    print('Ошибка')
finally:
    print(file.closed)
```

```python
try:
    x = 1 / 0
except Exception as p:
    print(p, type(p))  
# division by zero, <class 'ZeroDivisionError'>
```

## try-except-else-finally

Помимо `try-except`, в конструкции могут присутствовать `else` и `finally`. Блок `else` выполняется только в том случае, если в блоке `try` не возникло исключение. Блок `finally` используется для выполнения кода, независимо от того, возникло исключение или нет. Блок `finally` содержит код, который должен быть выполнен в любом случае. Блоки `else` и `finally` являются не обязательными блоками.

```python
try:
    # Код, который может вызвать исключение
except Exception:
    # Код, который обрабатывает исключение
else:
    # Код, который выполняется, если исключение не возникло
finally:
    # Код, который выполняется в любом случае
```

```python
try:
    x = int("42")
except ValueError:
    print("Ошибка преобразования типа")
else:
    print("x =", x)
```

```python
try:
    x = int("42")
except ValueError:
    print("Ошибка преобразования типа")
else:
    print("x =", x)
finally:
    print("Конец программы")
```

## raise

В Python оператор `raise` используется для генерации исключений. Он позволяет программисту явно указать, что произошла ошибка или некорректная ситуация, и вызвать соответствующее исключение.

```python
raise [ExceptionType("Error message")]
```

Где `ExceptionType` - это тип исключения, которое нужно сгенерировать, а `"Error message"` - это опциональное сообщение об ошибке, которое будет выводиться при возникновении исключения.

```python
def count(x, y):
    if y == 0:
        raise ZeroDivisionError('в функции count, y = 0, на ноль делить нельзя')
    return x / y

try:
    result = count(5, 0)
except ZeroDivisionError as zero:
    print(zero)  # в функции count, y = 0, на ноль делить нельзя
else:
    print(result)
```

## Пользовательские исключения

В Python можно создавать собственные типы исключений. Такая практика позволяет увеличить гибкость процесса обработки ошибок в рамках той предметной области, для которой написана программа.

Для создания собственного типа исключения необходимо создать класс, являющийся потомком (наследником) одного из уже существующих типов исключений. Как уже было сказано в прошлом уроке, самым верным вариантом является класс `Exception`.

Приведенный ниже код:

```python
class NegativeAgeError(Exception):
    pass
```

описывает новый тип исключения с именем `NegativeAgeError`, который является потомком класса `Exception`. Класс `Exception` содержит весь необходимый функционал, позволяющий работать с исключениями, поэтому в большинстве случаев достаточно создать пустой класс, который является потомком класса `Exception`.

Приведенный ниже код:

```python
try:
    print('Введите свой возраст')
    age = int(input())
    if age < 0:
        raise NegativeAgeError('Возраст не может быть отрицательным')
    print('Ваш возраст равен', age)
except ValueError:
    print('Возраст должен быть числом')
except NegativeAgeError as e:
    print(e)
```

при вводе некорректных значений приводит к возбуждению соответствующих типов исключений:

- `ValueError` – при нечисловых значениях 
- `NegativeAgeError` – при отрицательных числовых значениях

## Методики LBYL и EAFP

При написании программного кода, который может потенциально возбуждать исключения, существуют два основных подхода:

- **LBYL (Look Before You Leap)** — посмотри перед прыжком
- **EAFP (Easier to Ask Forgiveness than Permission)** — проще извиниться, чем спрашивать разрешение

### LBYL
**Способ 1.** Перестраховаться и заранее проверить, что все получится. Это идеология LBYL-подхода. Сначала посмотрели, убедились, что все в порядке, только потом сделали.

```python
data = {'Timur': 29, 'Ivan': 54}

if 'Anri' in data:
    data['Anri'] += 1
else:
    print('Ключ Anri отсутствует в словаре.')
```

### EAFP

**Способ 2.** Мы можем описывать только главный алгоритм, рассчитывая, что все будет хорошо. Но при таком подходе необходимо прописать действия с исключениями (иногда разных типов). Это суть подхода EAFP.

```python
data = {'Timur': 29, 'Ivan': 54}

try:
    data['Anri'] += 1
except KeyError:
    print('Ключ Anri отсутствует в словаре.')
```