
# Сырые строки и экранирование

В языке Python некоторые символы нужно экранировать, чтобы они воспринимались правильно. К таким символам относятся:

- обратный слэш `\`
- одинарная кавычка `'`
- двойная кавычка `"`
- и многие другие

Чтобы написать правильно строку, в которой находятся два символа обратного слэша `\\`, оба символа надо экранировать, и в итоге получится строка вида `\\\\`. Вместо экранирования можно использовать сырые (raw) строки, и тогда каждый символ будет восприниматься так, как написан. Сырые строки отличаются от обычных тем, что при создании строки вначале пишется буква `r`.

Приведенный ниже код:

```python
print(r'\\привет мир')
print(r'\\\\')
print(r'\n')
print(r'\t')
```

выводит:

```no-highlight
\\привет мир
\\\\
\n
\t
```


# Импорт модуля

За регулярные выражения в python отвечает модуль `re`

```python
import re
```

# Специальные символы

Если специальный символ нужно использовать как обычный то его нужно экранировать слешем
## `[]` - набор символов

```python
import re
text = 'Еду, беда, победа'
match = re.findall(r'[еЕ]д[ау]', text)
print(match
# вывод
#['Еду', 'еда', 'еда']
```

```python
import re
text = 'some слово word -5 55 лес море text'
match = re.findall(r"[а-яА-Я]",text)
print(match)
#['с', 'л', 'о', 'в', 'о', 'л', 'е', 'с', 'м', 'о', 'р', 'е']
```

## `-` - диапазон чисел `[0-9]` или букв `[a-zA-Z]`

```python
import re
text = '''
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
sam.csv
na1.csv
na2.csv
sa1.csv
ca1.csv'''

regex = r'[sn]a[0-9]\.csv'

res = re.findall(regex, text)
print(res)
```

Выводит:

```
['na1.csv', 'na2.csv', 'sa1.csv']
```

Можно инвертировать наборы символов, используя метасимвол `^`.

```python
import re
text = '''
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
sam.csv
na1.csv
na2.csv
sa1.csv
ca1.csv'''

regex = r'[sn]a[^0-9]\.csv'

res = re.findall(regex, text)
print(res)
```

Вывод:

```python
['sam.csv']
```

## `\d` - найти все числа

```python
import re
text = 'Еду, беда, 4 победа'
match = re.findall(r'\d', text)
print(match)
#вывод
#['4']
```

## `\D` - найти все не числа

```python
import re
text = 'some word -5 55 text'
match = re.findall(r"\D+",text)
print(match)
#['some word -', ' ', ' text']
```

## `\w` - найти все символы

```python
import re
text = '123 @some word# 45'
res = re.findall(r"\w", text)
print(res)
```

## `\s` - найти все пробелы

```python
import re
text = 'some слово word -5 55 лес море text'
match = re.findall(r"\s",text)
print(match)
# [' ', ' ', ' ', ' ', ' ', ' ', ' ']

```

```python
import re
text = 'some word -5 55 text'
match = re.findall(r"\w+",text)
print(match)
#['some', 'word', '5', '55', 'text']
```

## `.` - найти любой символ

```python
import re
text = 'some слово word   -5 55 лес море text'
match = re.findall(r".*",text)
print(match)
#['some слово word   -5 55 лес море text', '']
```

## `{m,n}` `*` `+` `?` - квантификаторы (минимальное,максимальное число совпадений)

- *мажорный квантификатор*

```python
import re
text = 'Google, Gooogle, Gooooogle'
match = re.findall(r"o{2,5}",text)
print(match)
#['oo', 'ooo', 'ooooo'
```

- *минорный квантификатор*

```python
import re
text = 'Google, Gooogle, Goooooogle'
match = re.findall(r"o{2,5}?",text)
print(match)
# ['oo', 'oo', 'oo', 'oo', 'oo']
```

```python
import re
text = 'Google, Gooogle, Goooooogle'
match = re.findall(r"Go{,3}gle",text)
print(match)
# ['Google', 'Gooogle']
```

`?` - 0 или 1 число совпадений

```python
import re
text = 'стеклянный стекляный'
match = re.findall(r"стеклянн?ый",text)
print(match)
# ['стеклянный', 'стекляный']
```

`*` `+` - от 0 до бесконечность и от 1 до бесконечность 
`*?` `+?` - ленивые аналоги

```python
import re
text = 'some_word text one=1'
match = re.findall(r"\w+=*",text)
print(match)
# ['some_word', 'text', 'one=', '1']
```

## `()` и `|` - сохраняющие скобки  и группировка

Чтобы в одном регулярном выражении перечислить все необходимые шаблоны, их следует отделить друг от друга с помощью символа вертикальной черты `|`.

```python
import re
text = 'lat = 4, lan=5, pi = 3'
match = re.findall(r"(?:lat|lan)\s*=\s*\d",text)
print(match)
# вывод
['lat = 4', 'lan=5']
```

```python
import re
text = '''
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
sam.csv
na1.csv
na2.csv
sa1.csv
ca1.csv'''

regex = r'sales[0-9]|[ns]a[0-9]\.csv'

res = re.findall(regex, text)
print(res)
```

Вывод:

```
['sales1', 'sales2', 'sales3', 'na1.csv', 'na2.csv', 'sa1.csv']
```

```python
import re
text = "Пингую сайт www.stepik.org [13.69.75.239] 32 байтами данных."
regex = r"(\d{1,3}\.){3}\d{1,3}"
res = re.findall(regex, text)
print(res)
```
## `\b` - граница слова (отдельное слово, вокруг которого пробелы)

```python
import re
text = "The cat scattered his food all over the room."
regex = r"\bcat\b"
print(re.findall(regex, text))
```

Вывод:

```bash
['cat']
```

## `\B` - граница слова (слово окруженное символами)

## `^` - начало строки

```python
import re
text = "Hello, Timur. I haven't seen you for ages. I want to be his favorite hello and his hardest goodbye."
regex = r"^[Hh]ello"
print(re.findall(regex, text))
```

Вывод:

```bash
['Hello']
```

## `$` - конец строки

```python
import re
text = "Goodbye my dear friend, goodbye! I miss you so much. Goodbye"
regex = r"[Gg]oodbye$"
print(re.findall(regex, text))
```

Вывод:

```bash
['Goodbye']
```
# Методы

## `findall` - найти все вхождения

```python
import re
text = 'bitmap and map is different things'
match = re.findall('map', text)
print(match) 
# вывод
['map', 'map']
```

```python
import re
text = 'bitmap and map is different things'
match = re.findall(r'\bmap\b', text)
print(match)
```

## `search` - найти первое вхождение

 Приведенный ниже код:

```python
from re import search

match1 = search('super', 'superstition')
match2 = search('super', 'insuperable')
match3 = search('super', 'without')

print(match1)
print(match2)
print(match3)
```

выводит:

```no-highlight
<re.Match object; span=(0, 5), match='super'>
<re.Match object; span=(2, 7), match='super'>
None
```


## `match` - проверяет соответствует ли начало строки выражению

Приведенный ниже код:

```python
from re import match

match1 = match('super', 'superstition')
match2 = match('super', 'insuperable')

print(match1)
print(match2)
```

выводит:

```no-highlight
<re.Match object; span=(0, 5), match='super'>
None
```

## `fullmatch` - проверяет соответствует ли вся строка выражению


Приведенный ниже код:

```python
from re import fullmatch

match1 = fullmatch('\d+', '123foo')
match2 = fullmatch('\d+', 'foo123')
match3 = fullmatch('\d+', 'foo123bar')
match4 = fullmatch('\d+', '123')

print(match1)
print(match2)
print(match3)
print(match4)
```

выводит:

```no-highlight
None
None
None
<re.Match object; span=(0, 3), match='123'>
```


# Объекты типа Match 

Все три рассмотренные функции `search(), match(), fullmatch()` при успешном соответствии регулярному выражению возвращают объект типа `Match`. Объекты такого типа приводятся к типу `bool` автоматически, поэтому мы можем использовать их в условном операторе.

## Метод group()

Метод group() возвращает одну или несколько подгрупп совпадения

Приведенный ниже код:

```python
from re import search

match = search('(\w+),(\w+),(\w+)', 'foo,bar,baz')

print(match.group())                       # вся строка
print(match.group(0))                      # вся строка
print(match.group(1))                      # подгруппа
print(match.group(2))                      # подгруппа
print(match.group(3))                      # подгруппа
print(match.group(1, 2, 3))                # кортеж
```

выводит:

```no-highlight
foo,bar,baz
foo,bar,baz
foo
bar
baz
('foo', 'bar', 'baz')
```
## Метод groups()

Метод `groups()` возвращает кортеж, содержащий все захваченные группы.

Приведенный ниже код:

```python
from re import search

match = search('(\w+),(\w+),(\w+)?', 'foo,bar,')

print(match.groups())
```

выводит:

```no-highlight
('foo', 'bar', None)
```

Группы, которые не смогли захватить какой-либо результат, по умолчанию будут иметь значение `None`. Если в такой ситуации требуется вернуть значение, отличное от `None`, то используется необязательный аргумент `default`.


## Метод groupdict()

Метод `groupdict()` возвращает словарь, содержащий все захваченные именованные группы.

Приведенный ниже код:

```python
from re import search

match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)', 'foo,bar,baz')

print(match.groupdict())
```

выводит:

```no-highlight
{'w1': 'foo', 'w2': 'bar', 'w3': 'baz'}
```

Метод `groupdict()`, как и метод `groups()`, принимает необязательный аргумент `default`, который используется для указания значений групп, которые не смогли захватить какой либо результат. По умолчанию значение данного аргумента равно `None`.

Если именованных групп в исходном регулярном выражении нет, метод `groupdict()` возвращает пустой словарь.

## Методы start() и end()

Методы `start()` и `end()` возвращают индексы начала и конца подстроки, которая совпала с регулярным выражением.

Приведенный ниже код:

```python
from re import search

match = search('\d+', 'foo123bar456baz')

print(match)
print(match.start())
print(match.end())
```

Выводит:

```no-highlight
<re.Match object; span=(3, 6), match='123'>
3
6
```

## Метод span()

Метод `span()` возвращает индексы начала и конца подстроки в виде кортежа, которая совпала с регулярным выражением. В метод `span()` также можно передать номер или название группы. В этом случае метод вернет индексы начала и конца подстроки в виде кортежа, совпадающей с нужной группой.

Приведенный ниже код:

```python
from re import search

match = search('(\d+)\D+(?P<num>\d+)', 'foo123bar456baz')

print(match)
print(match.span())
print(match.span(1))
print(match.span('num'))
```

выводит:

```no-highlight
<re.Match object; span=(3, 12), match='123bar456'>
(3, 12)
(3, 6)
(9, 12)
```


