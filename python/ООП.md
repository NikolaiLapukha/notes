
## Базовый синтаксис

```python
class <Название класса>: # Определение класса
	def __init__(self): #Конструктор
        pass
```


Примеры:

```python
class Cat():
    def __init__(self, name, age, isHappy): # конструктор
        self.name = name
        self.age = age
        self.isHappy = isHappy

	def getData(self): # метод класса
        return f"Имя: {self.name}, возраст: {self.age}, счаслив ли: {self.isHappy}"
  
catLiova = Cat('Liova', 1.1, True)
```


## Функции атрибутов классов

### `getattr` - Возвращает значение атрибута объекта

```python
class Point():
    color = 'red'
    radius = 2

a = Point()
a.color = 'red'
print(getattr(Point, 'color')) # red
print(getattr(Point, 'perimetr')) # ошибка
print(getattr(Point, 'perimetr', False)) # False
```

### `hasattr` - Проверяет на наличие атрибута в объекте 

```python
print(hasattr(Point, 'color')) # True
```

### `setattr` - Задает значение атрибута, если атрибута нет, то создает его

```python
setattr(Point, 'x',  2)
print(Point.x) # 2
```

```python
file = {'name': 'Alex', 'age': 18, 'hobby': 'films'}

class Person:
    pass

id_1 = Person()

for key, value in file.items():
    setattr(id_1, key, value)      # используем цикл по file и создаём атрибуты в id_1
    # id_1.key = value             # через точку так не получится

print(id_1.hobby)  # films
```

### `delattr` - Удаляет атрибут с заданным именем 

```python
delattr(Point, 'x')
print(Point.x) # AttributeError: type object 'Point' has no attribute 'x'
```

### `__doc__` - Возвращает строку с описанием класса

```python
class Point():
    """Класс определяет объект точки"""
    color = 'red'
    radius = 2

a = Point()
print(Point.__doc__) # Класс определяет объект точки
```

### `__dict__` - Содержит набор атрибутов экземпляра класса

Существует `__dict__` экземпляра и `__dict__` класса, то есть это два разных хранилища. Атрибут `__dict__` экземпляра является _словарём_ и хранит _только атрибуты экземпляра_. Атрибут `__dict__` класса похож на словарь, но имеет некоторые ограничения, он хранит _только те атрибуты и методы, которые были определены (созданы) в классе_, а также другую информацию о классе. 

```python
print(Point.__dict__) # {'__module__': '__main__', '__doc__': 'Класс определяет объект точки', 'color': 'red', 'radius': 2, '__dict__': <attribute '__dict__' of 'Point' objects>, '__weakref__': <attribute '__weakref__' of 'Point' objects>}
```

## Методы класса

```python
class Point():
    'Класс определяет объект точки'
    color = 'red'
    radius = 2

    def doSome(self): # метод класса
        print('Метод класса')
        
    def setCoords(self, x, y): # метод класса
        self.x = x
        self.y = y

    def getCoors(self): # метод класса
        return(self.x, self.y)

	
a = Point()
a.doSome() # Метод класса

a.setCoords(2, 1)
print(a.getCoors()) # (2, 1)
```

## Инициализатор и финализатор

Инициализатор используется для автоматического создания атрибутов экземпляра класса при создании этого экземпляра. Или для автоматического выполнения каких-то действий при создании экземпляра класса.

Синтаксис:

```python
def __init__(self): # инициализотор он же конструктор
        
```

Пример:

```python
class Point():
    'Класс определяет объект точки'
    color = 'red'
    radius = 2
    def __init__(self, x, y): # инициализотор он же конструктор
        self.x = x
        self.y = y

    def getCoors(self):
        return(self.x, self.y)

a = Point(2, 3)
print(a.getCoors()) # (2, 3)
```

Финализатор используется для автоматического выполнения каких-то действий при удалении экзепляпа класса.

Синтаксис:

```python
def __del__(self): # Финализатор
```

Пример:

```python
    def __del__(self):
        print(f"remove object {self}")
# remove object <__main__.Point object at 0x7d73765a2bd0>
```

## `@classmethod` - Для манипуляций с атрибутами класса

```python
class Seasons:
    seasons = ['весна', 'лето', 'зима', 'осень']

    def __init__(self, season):
        self.season = season if self.season_check(season) \
            else 'Неизвестно'

    @classmethod
    def season_check(cls, season):
        return season.lower() in cls.seasons


print(Seasons.season_check('Весна'))
```
## `@staticmethod` - метод, не контактирующий с атрибутами класса и экземплярами, т.е. абсолютно независимый, но уместный т.к. соответствует тематике класса. 

```python
from random import choice as ch


class Seasons:
    seasons = ['весна', 'лето', 'зима', 'осень']

    def __init__(self, season):
        self.season = season if self.season_check(season) \
            else 'Неизвестно'

    @classmethod
    def season_check(cls, season):
        return season.lower() in cls.seasons

    @staticmethod
    def rand_fact():
        lst = ['Весна! Бабушки сбились в стаю на лавочке.',
               'Летом буду скидывать кожу как удав.',
               'Осенью деревья ржавеют.',
               'Зимой впаду вспячку.']
        return ch(lst)

print(Seasons.rand_fact())
```

## Инкапсуляция

*Инкапсуляция - процесс скрытия реализации некоторых деталей логики класса от внешних запросов*

Все методы и атрибуты изначально имеют публичный статус доступа. Чтобы ограничить их использование извне, перед такими методами или атрибутами прописывают нижнее подчеркивание, в таком случае режим доступа меняется на защищенный:

```python
class Windows:
    def __init__(self, name, key):
        self._name = name
        self._key = key


win = Windows('Windows 11 Professional', 'w4g4-f4b3-wd32-c45n')
print(win._name, win._key)
```

Если нужен более серьёзный уровень защиты, то можно использовать приватный уровень доступа. Для этого необходимо в начале имени переменной использовать двойное нижнее подчеркивание:

```python
class Spy:
    passphrase = 'ты пчела я пчеловод'
    data = 'секретные данные'

    @classmethod
    def __get_data(cls):
        return cls.data

    def get_secret_information(self, psw):
        if psw == self.passphrase:
            return self.__get_data()
        raise TypeError('Фраза неверна!')


spy = Spy()
print(spy.get_secret_information('ты пчела я пчеловод'))
```

raise - инструкция, позволяющая вызвать исключение.

## Property

`property` - класс декоратор для определения сеттера, геттера, делиттер.

```python
class Container:
    def __init__(self):
        self.__content = []

    def get_content(self):
        return self.__content

    def set_content(self, item):
        self.__content = item

    def del_content(self):
        del self.__content

    content = property(fget=get_content, fset=set_content, fdel=del_content)


cont = Container()
print(cont.content)
cont.content = ['вафли', 'крыжовник', 'казинаки']
print(cont.content)
del cont.content
print(cont.__dict__)
```

```python
class Container:
    def __init__(self):
        self.__content = []

    @property
    def content(self):
        return self.__content

    @content.setter
    def content(self, item):
        if 'хурьма' in item:
            raise TypeError('Хурьма категорически не надо!!!')
        self.__content = item

    @content.deleter
    def content(self):
        del self.__content


cont = Container()
print(cont.content)
cont.content = ['огурчики', 'киселёк']
print(cont.content)
```

## Дескрипторы

```python
class Descr:
    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value


class Capybara:
    age = Descr()
    color = Descr()

    def __init__(self, age, color='каштановый'):
        self.age = age
        self.color = color
```

## Наследование и полиморфизм

В Python наследование является одним из основных принципов объектно-ориентированного программирования. Оно позволяет создавать новые классы, называемые *дочерними* классами (*подклассами*), на основе уже существующих классов, называемых *родительскими* классами (*суперклассами, базовыми классами*). Для ясности будем использовать термины родительский и дочерний класс.
### Создание дочернего класса

```python
class Transport:        # Родительский класс
    pass        

class Car(Transport):   # Дочерний класс
    pass
```

### Наследование родительского класса

Когда мы объявляем дочерний класс, он наследуется от родительского класса и получает возможность обращаться к атрибутам и методам родительского класса.

```python
class Transport:           # Родительский класс
    name = 'car'
    def get_name(self):
        return self.name
 
class Car(Transport):      # Дочерний класс
    pass

toyota = Car()
print(toyota.name, toyota.get_name()) # car car
print(Car.name)  # car
```

Дочерний класс может пользоваться всем, что есть в родительском классе, если это не вызовет ошибки. Например класс `Car` может обратиться к `get_name()`, но это вызовет ошибку, потому что `get_name()` - это обычный метод, который вызывается экземпляром, а не классом. Но если бы `get_name()` был "методом класса" (вспомните @classmethod), то ошибки бы не возникло.

### Функции super()

Функция `super()`используется в основном для вызова методов родительского класса из методов дочернего класса. Вы же помните, что к обычным методам нельзя обратиться через класс. Но функция `super()` использует особый объект, который позволяет обращаться к методам родительского класса.

```python
class Cat:
    def hello_cat(self):
        self.name = 'hello cat'

class Dog(Cat):
    def hello_dog(self):
        super().hello_cat()
        


test = Dog()
test.hello_dog()     # вызвали метод дочернего класса hello_dog
print(test.name)     # hello cat
```

### Множественное наследование

Множественное наследование используется редко, но в определённых ситуациях оно конечно же используется. Множественное наследование в Python позволяет классу наследовать свойства и методы нескольких родительских классов. Это означает, что класс может наследовать функциональность от нескольких классов одновременно.

```python
class A:
    def method1(self):
        print("Method 1 from A")

class B:
    def method2(self):
        print("Method 2 from B")

class C(A, B):
    def method3(self):
        print("Method 3 from C")

child = C()

child.method1()  # Вывод: "Method 1 from A"
child.method2()  # Вывод: "Method 2 from B"
child.method3()  # Вывод: "Method 3 from C"
```

## Магические методы

### `__New__()` - Магический метод для автоматического выполнения чего либо перед созданием объекта класса

```python
class Point:
    def __new__(cls, *args, **kwargs):
        print('Вызов метода для __new__ ' + str(cls))
        return super().__new__(cls)


    def __init__(self, x=0, y=0):
        print('Вызов __init__ для ' + str(self))
        self.x = x
        self.y = y


p1 = Point()

#Вызов метода для __new__ <class '__main__.Point'>
#Вызов __init__ для <__main__.Point object at 0x77180b136900>
```

### `__getattribute__` - Магический метод получения атрибута

Скорее всего вы не знали, но каждый раз когда мы вызываем атрибут через точку, активируется метод __getattribute__ и возвращает нам значение этого атрибута. Метод __getattribute__ вызывается независимо от того, существует атрибут или нет. Получается, что __getattribute__ - это метод, который позволяет получить значение атрибута объекта по его имени.

**Синтаксис**
По умолчанию __getattribute__ выглядит так:

```python
def __getattribute__(self, item):
    return object.__getattribute__(self, item)  # возвращает значение атрибута
```

- self - это **экземпляр класса**, для которого вызывается метод.
- item - это **имя атрибута**, к которому происходит обращение.

### `__getattr__` - Магический метод получения неизвестных атрибутов

Метод __getattr__ предоставляет возможность определить поведение при обращении к несуществующим атрибутам объекта. Он позволяет программисту контролировать, что происходит при попытке доступа к неизвестным атрибутам и предоставлять альтернативное поведение или возвращать значение по умолчанию.

Синтаксис

```python
def __getattr__(self, item):
    # код, определяющий поведение при обращении к несуществующему атрибуту
```

- self - ссылка на сам объект.
- item - имя атрибута, к которому происходит обращение.

```python
class Person:
    def __getattr__(self, item):
        return f"Атрибут {item} не найден"

person = Person()
print(person.age)  # Вывод: Атрибут age не найден
```

### `__setattr__` - Магический метод установки значения атрибута

Метод `__setattr__` - вызывается при установке значения атрибута экземпляра и позволяет определить поведение при установке значения атрибута экземляра. Метод `__setattr__` - вызывается независимо от того, существует ли этот атрибут или нет. Внутри метода `__setattr__` необходимо также использовать конструкцию с `object`, либо функцию `super()` для вызова оригинальной реализации метода из корневого класса `object` или родительского класса (в случае с super).

```python
def __setattr__(self, name, value):    
    object.__setattr__(self, name, value)  # устанавливает значение value атрибуту name

# или:

​def __setattr__(self, name, value):    
    super().__setattr__(name, value)  # устанавливает значение value атрибуту name
```

- self - ссылка на сам объект
- name - имя атрибута
- value - значение, которое требуется установить

### `__delattr__` - Магический метод удаления атрибута

__delattr__ -  позволяет определить поведение при удалении атрибута объекта. Он вызывается каждый раз, когда происходит попытка удалить атрибут объекта. Метод __delattr__ может быть использован для определения дополнительных действий или запрета удаления определенных атрибутов. В __delattr__ также нужно использовать object, или функцию super() для удаления объекта.

```python
class Person:
    def __delattr__(self, name):
        print(f"Атрибут {name} удален")
        super().__delattr__(name)

person = Person()
person.name = "Vasya"

del person.name  # Атрибут name удален
```

```python
class Immutable:
    def __delattr__(self, name):
        raise AttributeError(f"Запрещено удалять атрибут {name}")

immutable_obj = Immutable()
immutable_obj.age = 18
del immutable_obj.age  # AttributeError: Запрещено удалять атрибут age
```

### `__eq__` и `__ne__` - Магические методы сравнения атрибутов равно не равно

Методы __eq__ (equal) и __ne__ (not equal), позволяют программисту определить, как экземпляры будут сравниваться между собой, или с другими объектами. Если вы используете операторы == или != с экземплярами класса, то вы должны объявить в классе методы __eq__ и __ne__. В этих методах вы конкретно указываете, что будет происходить когда сравниваются экземпляры класса.

```python
def __eq__(self, other):
    # код для сравнения объектов
    return результат сравнения

def __ne__(self, other):
    # код для сравнения объектов
    return результат сравнения
```

- Здесь self - это текущий объект, а other - объект, с которым происходит сравнение.

```python
class Cord:
    def __init__(self, x):
        self.x = x

cord1 = Cord(50)
cord2 = Cord(50)
print(cord1 == cord2)  # False
```

На самом деле, здесь сравниваются id этих объектов, а он у них разный, поэтому результат False.


```python
class Cord:
    def __init__(self, x):
        self.x = x

    def __eq__(self, other):
        return self.x == other.x

cord1 = Cord(50)
cord2 = Cord(50)
print(cord1 == cord2)  # True
print(cord1 != cord2)  # False
```

В примере мы сравниваем два экземпляра. В методе __eq__ мы указали, что конкретно происходит, когда присутствует оператор `==` с объектами класса. Команда `print(cord1 == cord2)` запускает метод `__eq__(cord1, cord2)` , а далее сравниваются атрибуты "х" этих экземпляров, и возвращается результат сравнения.

Когда используется оператор "!=", интерпретатор ищет метод __ne__, если не находит, использует __eq__ и инвертирует его результат. В нашем случае __ne__ мы не использовали, поэтому команда `print(cord1 != cord2)` запускает метод `__eq__(cord1, cord2)`, но при этом возвращает инвертированный результат __eq__ (то есть False).


В примере выше, правильнее было объявить метод __ne__, вариант мог быть такой:

```python
def __ne__(self, other):
    return self.x != other.x
```

Но чаще используют универсальный вариант:

```python
def __ne__(self, other):
    return not self.__eq__(other)
```

В универсальном варианте, мы запускаем __eq__ с параметром (other) и возвращаем противоположный результат за счёт оператора not.

### `__lt__` и `__gt__` - Магические методы сравнения атрибутов меньше чем и больше чем

Методы `__lt__` и `__gt__` - сокращения от "less than" и "greater than" соответственно. Метод `__lt__` определяет поведение оператора меньше "<" , а метод `__gt__` определяет поведение оператора больше ">". Логика работы с этими методами подобна логике работы с методами `__eq__`  и __ne__ из прошлой статьи. Когда вы применяете операторы "<" или ">" с объектами класса, то активируются методы `__lt__` и `__gt__`.

```python
def __lt__(self, other):
    # ваш код
    return результат сравнения

def __gt__(self, other):
    # ваш код
    return результат сравнения
```

```python
class Person:
    pass

id1 = Person()
id2 = Person()

print(id1 < id2)  # вызовет ошибку
print(id1 > id2)  # вызовет ошибку
```

```python
class Person:
    def __init__(self, age):
        self.age = age

    def __lt__(self, other):
        return self.age < other.age

id1 = Person(18)
id2 = Person(22)

print(id1 < id2)  # True
print(id1 > id2)  # False
```


### `__le__` и `__ge__` - Магические методы сравнения атрибутов меньше или равно и больше или равно

Методы `__le__` и `__ge__` возникли из слов "less or equal" и "greater or equal" соответственно. Эти методы используются для определения поведения операторов `<=` и `>=` соответственно. Логика работы такая же, как и в предыдущих темах. Когда вы применяете операторы `<=` или `>=` с объектами класса, то активируются методы `__le__` и `__ge__`.

```python
def __le__(self, other):
    # ваш код
    return результат сравнения

def __ge__(self, other):
    # ваш код
    return результат сравнения
```

Если не объявлять методы __le__ и __ge__ , то нельзя сравнивать экземпляры.

```python
class Person:
    pass

id1 = Person()
id2 = Person()

print(id1 <= id2)  # вызовет ошибку
print(id1 >= id2)  # вызовет ошибку
```

Достаточно использовать только `__le__` или только `__ge__`

```python
class Person:
    def __init__(self, age):
        self.age = age

    def __le__(self, other):
        return self.age <= other.age

id1 = Person(18)
id2 = Person(22)

print(id1 <= id2)  # True
print(id1 >= id2)  # False
```


###  `__add__` , `__radd__` , `__iadd__` - Магические методы сложения атрибутов 

Специальный метод `__add__` используется для сложения (+) объектов. Он позволяет нам складывать экземпляры с экземплярами, числами, строками и др. У метода __add__ есть "дополнительные" методы `__radd__` и `__iadd__` , они также используются в сложении, расширяя функционал вашего кода.

При выборе __add__ , __radd__ и __iadd__ , важно понимать, с какой стороны находится экземпляр в математической операции и используется ли оператор `+=` . Например:

```python
result1 = экземпляр + 100  # используется __add__
result2 = 100 + экземпляр  # используется __radd__
экземпляр += экземпляр     # используется __iadd__
экземпляр += 100           # используется __iadd__
```

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __add__(self, other):
        return self.number + other

num1 = Number(2)
result1 = num1 + 88  # выполняется __add__(num1, 88)
print(result1)       # 90

result2 = 88 + num1  # ошибка
```

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __iadd__(self, other):
        if isinstance(other, Number):
            self.number += other.number
            return self
        if isinstance(other, int):
            self.number += other
            return self

num1 = Number(10)
num2 = Number(20)

num1 += num2
print(num1.number)  # 30
num1 += 40
print(num1.number)  # 70
```

### `__sub__` - Магический метод вычитания атрибутов

Специальный метод `__sub__` в Python используется для определения оператора вычитания (-) между объектами. Он позволяет определить, как объекты должны быть вычтены друг из друга и возвращать результат этой операции. Метод __sub__ похож на метод `__add__` , только выполняет вычитание, а не сложение. Здесь также, как и в сложении, если экземпляр находится справа в операции вычитания, то нужно использовать метод `__rsub__` . А если есть оператор `-=` , используется метод `__isub__`.

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __sub__(self, other):
        return self.number - other    # экземпляр вычитает число

    def __rsub__(self, other):
        return other - self.number    # число вычитает экземпляр

num1 = Number(10)
result1 = 5 - num1       # вызовет __rsub__
result2 = num1 - 5       # вызовет __sub__
print(result1, result2)  # -5 5
```

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __sub__(self, other):
        return self.number - other.number   # экземпляр вычитает экземпляр

    def __rsub__(self, other):
        return other - self.number          # число вычитает экземпляр

num1 = Number(100)
num2 = Number(30)
num3 = Number(20)
result = num1 - num2 - num3  # выполняется __sub__ и __rsub__
print(result)                # 50
```

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __isub__(self, other):
        if isinstance(other, Number):
            self.number -= other.number  # экземпляр вычитает экземпляр
            return self
        if isinstance(other, int):
            self.number -= other         # экземпляр вычитает число
            return self

num1 = Number(50)
num2 = Number(20)

num1 -= num2
print(num1.number)  # 30
num1 -= 30
print(num1.number)  # 0
```

### `__mul__` - Магический метод умножение атрибутов

Специальный метод __mul__ в Python используется для определения оператора умножения (*) между объектами. Здесь всё также как в сложении и вычитании:

- Для формата экземпляр * объект используется метод __mul__ .
- Для формата объект * экземпляр используется метод __rmul__ .
- Для формата экземпляр *= объект используется метод __imul__ .

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __mul__(self, other):
        return self.number * other  # экземпляр на число

    def __rmul__(self, other):
        return other * self.number  # число на экземпляр

num1 = Number(10)
result1 = 5 * num1       # вызовет __rmul__
result2 = num1 * 7       # вызовет __mul__
print(result1, result2)  # 50 70
```

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __mul__(self, other):
        return self.number * other.number   # экземпляр на экземпляр

    def __rmul__(self, other):
        return other * self.number  # число на экземпляр

num1 = Number(10)
num2 = Number(5)
num3 = Number(2)
result = num1 * num2 * num3  # выполняется __mul__ и __rmul__
print(result)  # 100
```

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __imul__(self, other):
        if isinstance(other, Number):
            self.number *= other.number  # экземпляр на экземпляр
            return self
        if isinstance(other, int):
            self.number *= other         # экземпляр на число
            return self

num1 = Number(5)
num2 = Number(2)

num1 *= num2
print(num1.number)  # 10
num1 *= 3
print(num1.number)  # 30
```

### `__pow__` - Магический метод возведения в степень атрибутов

Метод __pow__ в Python является специальным методом, который позволяет возвести в степень объект. Он вызывается при использовании оператора ** или функции `pow()` для объектов класса, в котором он определен.

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __pow__(self, power):
        if isinstance(power, int) or isinstance(power, float):
            return self.number ** power

num = Number(2)
print(num ** 3)  # 8
```

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __rpow__(self, power):
        if isinstance(self.number, int) and isinstance(power, int):
            return power ** self.number

num = Number(2)
print(3 ** num)  # 9
```

### `__truediv__` - Магический метод деления атрибутов

Специальный метод `__truediv__` в Python используется для определения оператора деления (/) между объектами. Он позволяет определить, как объекты должны быть разделены и возвращать результат этой операции. Здесь всё также как и в предыдущих темах, только помните, что на ноль делить нельзя, а если экземпляр справа то используйте метод `__rtruediv__`.


```python
class Number:
    def __init__(self, number):
        self.number = number

    def __truediv__(self, other):
        if isinstance(other, int) and other != 0:
            return self.number / other

    def __rtruediv__(self, other):
        if self.number != 0:
            return other / self.number

num1 = Number(50)
result1 = 100 / num1     # вызовет __rtruediv__
result2 = num1 / 5       # вызовет __truediv__
print(result1, result2)  # 2.0 10.0
```

```python
class Number:
    def __init__(self, number):
        self.number = number

    def __truediv__(self, other):
        if isinstance(other, Number) and other.number != 0:
            return self.number / other.number


num1 = Number(50)
num2 = Number(10)
result = num1 / num2  # вызовет __truediv__
print(result)         # 5.0
```


### `__abs__` - Магический метод получения модуля атрибута

`__abs__` - это специальный метод в Python, который возвращает абсолютное значение числа. Он вызывается при использовании встроенной функции `abs()` для объекта.

```python
class MyNumber:
    def __init__(self, value):
        self.value = value

    def __abs__(self):
        return abs(self.value)

my_number = MyNumber(-5)
print(abs(my_number))  # Output: 5
```

### `__str__` - Магический метод строкового представления экземпляра

С помощью специального метода __str__ мы можем создавать информацию об экземпляре. Для этого нужно объявить метод __str__ внутри класса и создать информацию, которую мы хотим видеть, вызывая объект через print().

```python
def __str__(self):
    return "строковое представление объекта"
```

```python
class Person:
       def __init__(self, name, age):
           self.name = name
           self.age = age

       def __str__(self):
           return f"{self.name}, {self.age} лет"

person = Person("Vasya", 25)
print(person)  # Vasya, 25 лет
```

### `__repr__` - Магический метод строкового представления экземпляра используется для отладки, сериализации и воссоздания объектов


Специальный метод __repr__ (representation, представление), почти тоже самое что и __str__, отличие лишь в названии, цели использования и формате вызова. Метод __repr__ используется для отладки, сериализации и воссоздания объектов, а метод __str__ используется для информативного представления объекта для пользователей.

Если говорить простым языком, то в __str__ вы создаёте информацию об объекте, которую может запросить пользователь, а в __repr__ вы создаёте информацию об объекте, которая принесёт пользу программисту.

```python
class MyClass:
    def __str__(self):
        return f'Метод __str__'

    def __repr__(self):
        return f'Метод __repr__'


test = MyClass()
print(test)           # Метод __str__
print(repr(test))     # Метод __repr__
```

```python
class MyClass:
    def __repr__(self):
        return f'Метод __repr__'

person = MyClass()
print(person)  # Метод __repr__
```

### `__hash__` - Магический метод возвращает хэш-значение объекта.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __hash__(self):
        return hash((self.name, self.age))

person1 = Person("Vasya", 25)
person2 = Person("Masha", 30)
person3 = Person("Masha", 30)

print(hash(person1))  # 8796873826
print(hash(person2))  # 2738403829
print(hash(person3))  # 2738403829
```

### `__getitem__ , __setitem__ и __delitem__` - Магические методы предоставляют возможность работать с объектами как с коллекциями или контейнерами.

Магические методы `__getitem__`, `__setitem__` и `__delitem__` в Python предоставляют возможность работать с объектами как с коллекциями или контейнерами. С их помощью можно получать, изменять и удалять элементы объекта по ключу или индексу, аналогично работе со списками и словарями. Проще говоря, эти методы позволяют превратить экземпляр класса в подобие списка или словаря, предоставляя доступ к элементам, изменение их значений и возможность удаления.

#### `__getitem__`

Метод `__getitem__` используется для получения значения по индексу или ключу, аналогично работе со списками и словарями. При обращении к экземпляру класса через квадратные скобки `[]`, например, `экземпляр[индекс]` или `экземпляр[ключ]`, автоматически вызывается метод `__getitem__`.


```python
class MyList:
    def __init__(self):
        self.data = []

    def __getitem__(self, item):
        # возвращает элемент при обращении по индексу
        return self.data[item]

    def append(self, value):
        # создаём собственный метод append, который добавляет элементы
        self.data.append(value)

    def __str__(self):
        # используем __str__ для вывода информации о содержимом self.data в виде строки
        return str(self.data)


my_list = MyList()
my_list.append(777)  # вызывает созданный в классе метод append, который добавляет элементы
print(my_list[0])    # Выводит: 777  # используется __getitem__ для получения информации по индексу
print(my_list)       # [777]  # используется __str__ для вывода информации
```

```python
class MyDict:
    def __init__(self):
        self.data = {}

    def add(self, key, value):
        # создаём свой собственный .add() для добавления пар ключ-значение
        self.data[key] = value

    def __getitem__(self, item):
        # будет возвращать элемент при обращении по ключу
        return self.data[item]

    def __str__(self):
        # используем __str__ для вывода информации о содержимом self.data в виде строки
        return str(self.data)


my_dict = MyDict()
my_dict.add(key=1, value='a')  # добавляем пару, используя собственный метод add()
print(my_dict[1])    # Выводит: 'a' # используется __getitem__ для получения значения по ключу
print(my_dict)       # {1: 'a'}  # используется __str__ для вывода информации
```

#### `__setitem__` 

Метод `__setitem__` позволяет добавлять новые элементы или изменять существующие, тем самым имитируя поведение списка или словаря. 

Метод `__setitem__` автоматически вызывается при использовании конструкции `экземпляр[индекс] = значение` или `экземпляр[ключ] = значение`. Важно отметить, что этот метод не возвращает значение (не использует return), а только изменяет состояние объекта.

```python
class MyList:
    def __init__(self):
        self.data = [1, 2, 3]

    def __setitem__(self, index, value):
        # обновляет существующий элемент в атрибуте data
        self.data[index] = value

    def __str__(self):
        # используем __str__ для вывода информации о содержимом self.data в виде строки
        return str(self.data)


my_list = MyList()
my_list[1] = 777
print(my_list)  # [1, 777, 3]
```

```python
class MyDict:
    def __init__(self):
        self.data = {}

    def __setitem__(self, key, value):
        self.data[key] = value

    def __str__(self):
        # используем __str__ для вывода информации о содержимом self.data в виде строки
        return str(self.data)


my_dict = MyDict()
my_dict['name'] = 'Vasya'
print(my_dict)  # {'name': 'Vasya'}
my_dict['name'] = 'Masha'
print(my_dict)  # {'name': 'Masha'}
```

#### `__delitem__`

Метод, который позволяет удалять объект коллекции по индексу, по аналогии со списками.

```python
class MyList:
    def __init__(self):
        self.data = [1, 2, 3, 4, 5]

    def __delitem__(self, index):
        # удаляет элемент из списка по индексу
        del self.data[index]

    def __str__(self):
        # используем __str__ для вывода информации о содержимом self.data в виде строки
        return str(self.data)

my_list = MyList()
del my_list[2]
print(my_list)  # [1, 2, 4, 5]
```

```python
class MyDict:
    def __init__(self):
        self.data = {'name1': 'Vasya', 'name2': 'Masha'}

    def __delitem__(self, key):
        # удаляет элемент из словаря по ключу
        del self.data[key]

    def __str__(self):
        # используем __str__ для вывода информации о содержимом self.data в виде строки
        return str(self.data)


my_dict = MyDict()
del my_dict['name1']
print(my_dict)  # {'name2': 'Masha'}
```


### `__len__` - Магический метод который возвращает длину объекта.

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __len__(self):
        return len(self.items)

my_list = MyList([1, 2, 3, 4, 5])
print(len(my_list))  # Output: 5
```

```python
class MyString:
    def __init__(self, string):
        self.string = string

    def __len__(self):
        return len(self.string)

my_string = MyString("Hello, World!")
print(len(my_string))  # Output: 13
```

### `__iter__ и __next__` - Методы __iter__ и __next__ позволяют сделать **экземпляры - итерируемыми объектами**.

Методы `__iter__` и `__next__` позволяют сделать наши **экземпляры - итерируемыми объектами**. Это значит, что мы можем использовать экземпляры класса, например в цикле `for`. Чтобы понять, как пользоваться данными методами, вам нужно разобраться в том, в какой момент активируются эти методы, и какие условия важны чтобы объект стал итерируемым.

```python
class MyClass:
    # представим, что мы объявили методы __iter__ и __next__

my = MyClass()
for i in my:
    # код цикла
```

Когда запускается for i in my происходит вот что:

1. Сначала вызывается метод __iter__ и всё, что объявлено внутри этого метода, в конце возвращаем итератор.
2. Вызывается метод __next__ и всё, что объявлено внутри этого метода.
3. Вызывается "код цикла", например print(i).
4. Далее повторяется пункт 2 и 3, потом опять 2 и 3 до тех пор, пока не вызовется исключение StopIteration в методе __next__. Исключение StopIteration всегда прописывается в методе __next__.


```python
class MyClass:
    def __iter__(self):
        return self

    def __next__(self):
        # код, который будет запускаться с каждой итерацией
```

Пример реализации метода __next__ :

```python
def __next__(self):
        if self.index >= len(self.data): # условия для выхода из итераций
            raise StopIteration
        item = self.data[self.index]     # self.data - это список по которому итерируемся
        self.index += 1                  # счётчик итераций, self.index - используем как индекс
        return item
```


### `__enter__` и `__exit__` - Магические методы контекстного менеджера

С помощью методов `__enter__` и `__exit__`, мы можем работать с контекстным менеджером `with`, используя классы или экземпляры.  Сам контекстный менеджер позволяет выполнять такие операции, как открытие и закрытие файлов, работа с сетевыми подключениями, соединение с базами данных. Для лучшего понимания, повторите тему `with`, если совсем не понимаете, что это такое.

```python
def __enter__(self):
    # Код, который должен быть выполнен до блока
    return self

def __exit__(self, exc_type, exc_value, traceback):
    # Код, который должен быть выполнен после блока
```


### `__call__` - магический метод позволяет экземпляру класса быть вызываемым объектом, то есть объектом, который может быть вызван, как функция.

Метод `__call__` позволяет экземпляру класса быть вызываемым объектом, то есть объектом, который может быть вызван, как функция. Экземпляр вызывается за счёт оператора вызова (скобки). Когда вызывается экземпляр, интерпретатор Python автоматически вызывает метод `__call__` этого экземпляра. Метод `__call__` позволяет использовать экземпляр как функцию, а также создавать классы-декораторы.

```python
class MyClass:
    def __call__(self, *args, **kwargs):
        # ваш код
        return результат
```

```python
сlass Adder:
    def __init__(self, x):
        self.x = x

    def __call__(self, y):
        return self.x + y

adder = Adder(5)
result = adder(3)
print(result)  # Вывод: 8
```

```python
class Decorator:
    def __init__(self, f):
        self.func = f  # атрибут func ссылается на my_function

    def __call__(self, *args, **kwargs):
        print("До вызова функции")
        self.func(*args, **kwargs)    # запускаем функцию
        print("После вызова функции")

@Decorator
def my_function():
    print("Работа функции my_function")

my_function()

# До вызова функции
# Работа функции my_function
# После вызова функции
```


### `__class__` - Магический метод, который позволяет неявно использовать имя класса.

`__class__` - это специальный атрибут, который позволяет неявно использовать имя класса. С помощью конструкции экземляр.__class__  мы ссылаемся на класс, к которому принадлежит экземпляр. С помощью такой конструкции, можно обратиться к атрибутам и методам класса, а также узнать, к какому классу относится экземпляр. 

```python
class Класс:
    pass

экземпляр = Класс()
экземпляр.__class__.атрибут  # тоже самое что и Класс.атрибут
экземпляр.__class__.метод    # тоже самое что и Класс.метод
```

```python
class Класс:
    pass

экземпляр = Класс()
print(экземпляр.__class__)  # <class '__main__.Класс'>
print(Класс)                # <class '__main__.Класс'>
```

### `__module__` - это встроенный атрибут в Python, который содержит имя модуля, в котором был определен объект.

 Каждый объект в Python имеет этот атрибут, включая функции, классы и даже модули. И здесь есть важный момент, что значения __module__ объектов в стартовом модуле, всегда будут иметь `__main__` , а значения __module__ импортированных объектов будут иметь такое же, как название их модуля.

```python
import test_2   # импортируем модуль test_2

class Test1:
    pass


print(Test1.__dict__)
# {'__module__': '__main__' ...     

print(test_2.Test2.__dict__)    # класс из модуля test_2
# {'__module__': 'test_2'   ...     
```

### `__name__` - Атрибут имени модуля

```python
import test_2   # импортируем модуль test_2

print(__name__ == '__main__')         # True
print(test_2.__name__ == 'test_2')    # True
```


## Инкапсуляция 

*Инкапсуляция* - это один из принципов объектно-ориентированного программирования (ООП), который позволяет ограничить доступ к атрибутам или методам класса. Благодаря такому подходу злоумышленники или же мы сами не сможем случайно или намерено вызвать или изменить что-либо в классе.

### Основные принципы инкапсуляции в Python:

**1. Скрытие данных.** Инкапсуляция позволяет скрыть данные от прямого доступа. Для этого используют защищённые (protected) и приватные (private) атрибуты и методы. Подобные атрибуты и методы, нельзя вызвать напрямую через точку, но можно вызывать через специально созданный метод (геттер, сеттер).

**2. Методы доступа (геттеры и сеттеры).** По сути, геттеры и сеттеры - это обычные методы, и они позволяет обращаться к защищённым и приватным атрибутам и методам. Геттеры позволяют получить значение атрибута, а сеттеры позволяют изменить его значение. Геттеры и сеттеры нужны, потому что напрямую нельзя воздействовать на защищённые объекты.

**3. Декораторы**. Есть особые декораторы для работы с защищёнными данными. Например, декоратор @property позволяет определить геттеры и сеттеры для атрибутов класса.

### Public (обычные)

Public атрибуты и методы доступны из любого места программы. Говоря простым языком, публичные - это самые обычные атрибуты и методы, без нижних подчёркиваний _в начале имени_.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_data(self):
        print(f'{self.name}, {self.age}')

id1 = Person('Vasya', 18)
id1.print_data()          # Vasya, 18
print(id1.name, id1.age)  # Vasya 18 
```

### Protected (защищённые) атрибуты

Protected атрибуты и методы начинаются с одного символа подчеркивания (_). Атрибуты такого типа, не отличаются по функциональности от публичных, они лишь сигнализируют программисту, что такие атрибуты нужно использовать внутри класса и его наследников. Например, не рекомендуется выводить информацию о них с помощью функции `print` напрямую. Хотя это и возможно, но лучше создать метод внутри класса, который будет выводить на экран защищённые данные.

```python
class Person:
    def __init__(self, name, age):
        self._name = name    # защищённый атрибут _name
        self._age = age      # защищённый атрибут _age

    def print_data(self):
        print(f'{self._name}, {self._age}')

id1 = Person('Vasya', 18)
id1.print_data()             # Vasya, 18  
print(id1._name, id1._age)   # так возможно, но не рекомендуется
```

### Protected (защищённые) методы

Касаемо защищённых методов, здесь точно также: имя с одним нижним подчёркиванием в начале, и вызывается метод внутри, через обычный метод.

```python
class Person:
    def _vasya_cat(self):  # защищённый метод
        print('Васин кот любит царапать диван ...')

    def print_protected_method(self):   # обычный метод, который вызывает защищённый
        self._vasya_cat()

id1 = Person()
id1.print_protected_method()  # Васин кот любит царапать диван ...
```

### Private (приватные) атрибуты

Private атрибуты и методы начинаются с двух символов подчеркивания (__). Приватные атрибуты и методы доступны только внутри класса, и используются для полной инкапсуляции данных и функциональности класса. Полной, это значит их нельзя вызвать напрямую через точку. Это обеспечивает высокий уровень защиты данных и предотвращает их случайное изменение или использование.

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance
    
    def get_balance(self):
        return self.__balance

account = BankAccount(1500)
    
print(account.get_balance())    # 1500
print(account.__balance)        # Error
```

### Private (приватные) методы

С приватными методами всё точно также, их нельзя вызвать напрямую, только через обычный метод.

```python
class Person:
    def __vasya_code(self):
        print('Васин код от почты qwerty')

    def print_private_method(self):
        self.__vasya_code()

id1 = Person()
id1.print_private_method()  # Васин код от почты qwerty
```

### Наследование, protected и private

Как уже говорилось ранее, объекты protected можно использовать внутри класса и в дочерних классах, а объекты private - только внутри класса, где они созданы.

```python
class Parent:
    _x = 10
    def parent_x(self):
        print(self._x)

class Child(Parent):
    def child_x(self):
        print(self._x)


coordinate = Child()   # экземпляр дочернего класса
coordinate.parent_x()  # 10
coordinate.child_x()   # 10
```

```python
class Parent:
    __x = 10
    def parent__x(self):
        print(self.__x)

class Child(Parent):
    def child__x(self):
        print(self.__x)


coordinate = Child()    # экземпляр дочернего класса
coordinate.parent__x()  # 10
coordinate.child__x()   # AttributeError
```

В примерах мы говорили лишь об атрибутах (защищённых и приватных), но всё точно также работает и на методах (защищённых и приватных).

### Модуль accessify

Модуль accessify - это библиотека Python, которая позволяет создавать приватные и защищённые методы, используя декораторы. Чтобы использовать accessify, её необходимо установить и импортировать. В модуле accessify чаще всего используют декораторы @private и @protected.

```python
from accessify import private

class MyClass:
    a = 2
    b = 3

    @private
    def private_sum_ab(self):
        print(f"{self.a + self.b}")

    def public_sum_ab(self):
        self.private_sum_ab()

obj = MyClass()
obj.public_sum_ab()   # 5
obj.private_sum_ab()  # AttributeError
```

```python
from accessify import protected

class MyClass:
    @protected
    def _protected(self):
        print("Это защищённый метод")

    def _public(self):
        self._protected()

obj = MyClass()
obj._public()        # Это защищённый метод
obj._protected()     # AttributeError:
```


### Декоратор property (getter, setter, deleter)

Слово property переводится как - "свойство", а `свойства` и `атрибуты` в ООП - это одно и тоже. Декоратор `property` - это встроенный декоратор в python. С помощью него можно создавать методы `геттеры`, `сеттеры`, `делиттеры` и взаимодействовать с атрибутами, не нарушая принципы инкапсуляции.

#### Getter (геттер)

```python
class Person:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):            # метод стал геттером
        return self.__name

person = Person("Vasya")
print(person.name)  # Vasya
```

#### Setter (сеттер)

Setter - это метод, который позволяет устанавливать значение атрибута, от слова "set" - "установить". Setter может быть определен, только если создан `геттер`. Setter создаётся с помощью декоратора в котором указывают `имя геттера` и слово `setter` через точку _(@name.setter в примере)_.

```python
class Person:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):            # геттер
        return self.__name

    @name.setter               # name - потому что, имя геттера - "name"  
    def name(self, value):     # имя метода такое же как и у геттера - "name"
        self.__name = value

person = Person("John")
print(person.name) # John      # использовали геттер

person.name = "Vasya"          # использовали сеттер
print(person.name) # Vasya
```

#### Deleter (делитер)

```python
class Person:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):                   # имена методов одинаковые
        return self.__name    

    @name.deleter
    def name(self):                   # имена методов одинаковые
        del self.__name

person = Person("john")
print(person.__dict__) # {'_Person__name': 'john'}
del person.name        # использовали делитер 
print(person.__dict__) # {}
```

