## Простые типы

Рассмотрим определение функции `greet()`, которая по задумке принимает строковый аргумент `name` и возвращает строковое значение приветствия:

```python
def greet(name):
    return f'Hello {name}!'
```

С помощью аннотаций типов можем переписать функцию в виде:

```python
def greet(name: str) -> str:
    return f'Hello {name}!'
```

Если некоторый аргумент имеет значение по умолчанию, то его тип должен предшествовать значению по умолчанию:

```python
def greet(name: str = 'world') -> str:
    return f'Hello, {name}!'
```

Приведем несколько примеров.

**Пример 1.** Функция `print_hello()` принимает два аргумента типа `str` и `bool` и возвращает значение `None`.

```python
def print_hello(name: str, upper: bool = False) -> None:
    if upper:
        name = name.upper()
    print(f'Hello, {name}')
```

**Пример 2.** Функция `avg()` принимает три аргумента типа `int` и возвращает значение `float`:

```python
def avg(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3
```

Вот так можно добавить аннотации типов к переменным в любом месте кода (Python 3.6+):

```python
name: str = 'Timur'
age: int = 29
height: float = 171.5
is_married: bool = False
```

Можно также аннотировать переменные, не назначая им сразу значения:

```python
surname: str
gender: bool
```

## Типы коллекции

Перейдем к более сложным типам, таким как списки, кортежи, словари и множества. Можно добавлять аннотации типов, используя сами имена классов `list, tuple, set, dict`:

```python
def sum_square(nums: list) -> int:
    total = 0
    for i in nums:
        total += i ** 2
    return total
```

Начиная с Python 3.9 можно использовать стандартные классы в точно таких же целях, ничего ниоткуда не импортируя:

```python
numbers: list[int]                                # тип всех элементов списка
person: tuple[str, int, bool]                     # тип каждого элемента кортежа
prices: dict[str, int]                            # тип ключей, тип значений
answers: set[float]    
```

## Тип Optional

Также очень часто возникает ситуация, когда возможно либо значение определенного типа, либо `None`. Мы можем использовать тип `Union` следующим образом:

```python
from typing import Union

name: Union[str, None]
```

Однако это настолько частая ситуация, что для этого даже сделали отдельный тип `Optional`:

```python
from typing import Optional

name: Optional[str]
```

По сути `name: Union[str, None]` и `name: Optional[str]` это одно и то же, но второй вариант читается проще.

## Тип Any

Может возникнуть ситуация, когда не получается указать какой-либо конкретный тип, потому что, функция может принимать на вход абсолютно что угодно. Для этих случаев тоже есть специальный тип `Any`:

```python
from typing import Any

def func(arg: Any) -> Any:
    return arg
```

## Тип NoReturn

Специальный тип `NoReturn` указывает, что функция никогда не возвращает значение:

```python
from typing import NoReturn

def stop() -> NoReturn:
    raise RuntimeError('no way')
```

Не путайте тип `NoReturn` с типом `None`, который указывает на то, что функция возвращает конкретное значение — `None`.

## Примечания

**Примечание 2.** В Python 3.10 вместо записи `Union[X, Y]` можно писать `X | Y`.