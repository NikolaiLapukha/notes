# Итерируемые объекты

В языке Python под **итерируемым объектом** подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом. К примеру, уже известные нам списки (тип `list`), строки (тип `str`), кортежи (тип `tuple`), множества (тип `set`), словари (тип `dict`) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.

Приведенный ниже код:

```python
numbers = [1, 2, 3]
name = 'python'

for num in numbers:        # итерируем по списку, перебирая каждый элемент
    print(num)

for c in name:             # итерируем по строке, перебирая каждый символ
    print(c)

print(2 in numbers)        # неявное итерирование по списку
print('A' in name)         # неявное итерирование по строке
print(*numbers)   
```


**Если подходить более формально в Python, существует два типа итерируемых объектов:**

1. _итераторы_
2. _коллекции и последовательности_

# Итераторы

**Итератор** — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию `next()`, то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к возникновению исключения `StopIteration`.

Для того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию `iter()`, передав нужную коллекцию в качестве ее аргумента.

Например, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до последнего.

Приведенный ниже код:

```python
numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основании списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора
```

выводит:

```no-highlight
1
2
3
```

После того как мы получили итератор, мы можем передать его встроенной функции `next()`. При каждом новом вызове, функция `next()` возвращает очередной элемент итератора. Если же в итераторе элементов больше не осталось, то функция `next()` возбуждает исключение `StopIteration`.

Приведенный ниже код:

```python
numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основе списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора

print(next(iterator))             # возбуждается исключение StopIteration
```

приводит к возникновению исключения `StopIteration`.

# Преимущества итераторов

Основными преимуществами использования итераторов являются:

- однотипность работы с объектами разных типов
- ленивые вычисления и экономия потребляемой памяти
- комбинация множества итераторов для создания понятной и читабельной программы


## Ленивые вычисления и экономия потребляемой памяти

Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время на вычисление.

```python
numbers = range(5)             # 5 чисел в последовательности

for num in numbers:
    print(num)
```

Объекты типа `range` являются итерируемыми объектами. Цикл `for` создает на основе объекта `range` итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число 44.

Важно понимать, что объект типа `range` не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся. Размер объектов `range` не зависит от количества чисел, которые предполагается перебрать, ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение.

Приведенный ниже код:

```python
from sys import getsizeof

numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(getsizeof(numbers1))
print(getsizeof(numbers2))
print(getsizeof(numbers3))
```

выводит (размер в байтах):

```no-highlight
48
48
48
```

Все объекты `range` имеют один и тот же размер в памяти — 4848 байт. Такой подход позволяет создавать "большие" итераторы (даже бесконечные), не занимая много памяти.

Заметим, что мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.

## Комбинация множества итераторов

У итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом.

Приведенный ниже код:

```python
sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
```

выводит:

```no-highlight
1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
```


# Особенность функции iter()

Встроенная функция iter(), как мы уже знаем, преобразует итерируемый объект в итератор. Именно в таком виде функция используется в большинстве случаев.

iter(iterable) -> iterator
Однако мы можем использовать функцию iter() в еще одном полезном сценарии:

iter(callable, sentinel) -> iterator
Если функции iter() передается два аргумента, то первый аргумент callable должен являться функцией, а второй аргумент sentinel — некоторым стоп-значением. В этом случае, созданный итератор будет вызывать указанную функцию callable и проверять полученное значение на равенство со значением sentinel. Если полученное значение равно sentinel, то возбуждается исключение StopIteration, иначе итератор выдает значение, полученное из функции callable.

Например, с помощью функции iter() мы можем создать бесконечный итератор, генерирующий единственное значение — 0.

Приведенный ниже код:

```python
zero_iterator = iter(int, -1)

for i in range(5):
    print(next(zero_iterator))

print(type(zero_iterator))
```

выводит:

```no-highlight
0
0
0
0
0
<class 'callable_iterator'>
```



# Модуль itertools

Встроенный модуль `itertools` включает в себя множество функций, предназначенных для создания итераторов. Как мы уже знаем, код, основанный на итераторах, обеспечивает лучшие характеристики использования памяти, чем код, основанный на использовании списков.

Функции модуля `itertools` можно разделить на следующие категории:

1. порождающие данные
2. фильтрующие данные
3. преобразующие данные
4. группирующие данные
5. объединяющие или разделяющие данные
6. порождающие комбинаторные данные

## Функции, порождающие данные

К этой категории относятся следующие функции:

- `count()`
- `cycle()`
- `repeat()`

Все функции данной категории по умолчанию порождают **бесконечные итераторы**.

### Функция count()

Функция `count()` возвращает итератор, генерирующий бесконечную последовательность чисел.

Аргументы функции:

- `start` — начало отсчета, по умолчанию имеет значение 00
- `step` — шаг, по умолчанию имеет значение 11

В отличие от встроенной функции `range()`, в функции `count()` аргумент для задания верхней границы не предусмотрен.

Приведенный ниже код:

```python
from itertools import count

count1 = count()

print(next(count1))
print(next(count1), next(count1), next(count1))

count2 = count(69, 10)

print(next(count2))
print(next(count2))
print(next(count2), next(count2), next(count2))

for i in zip(count(10), ['a', 'b', 'c']):
    print(i)
```

выводит:

```no-highlight
0
1 2 3
69
79
89 99 109
(10, 'a')
(11, 'b')
(12, 'c')
```

Обратите внимание на то, что мы не можем создать список на основе итератора, который возвращает функция `count()`, поскольку он является бесконечным.

Аргументами `start` и `step` функции `count()` могут быть любые числовые значения, допускающие операцию сложения.

### Функция cycle()

Функция `cycle()` возвращает итератор, циклично генерирующий последовательность элементов переданного итерируемого объекта.

Аргументы функции:

- `iterable` — итерируемый объект

Обратите внимание на то, что функция `cycle()` сохраняет копию каждого элемента из `iterable`. Когда итерируемый объект `iterable` исчерпан, функция начинает возвращать элементы из сохраненной копии.

Приведенный ниже код:

```python
from itertools import cycle

for index, char in enumerate(cycle('abcd')):
    if index < 7:
        print(char)
    else:
        break

cycle_iter = cycle([0, 1])
print(next(cycle_iter), next(cycle_iter), next(cycle_iter), next(cycle_iter), next(cycle_iter))

for i in zip(range(7), cycle(['a', 'b', 'c'])):
    print(i)
```

выводит:

```no-highlight
a
b
c
d
a
b
c
0 1 0 1 0
(0, 'a')
(1, 'b')
(2, 'c')
(3, 'a')
(4, 'b')
(5, 'c')
(6, 'a')
```

### Функция repeat()

Функция `repeat()` возвращает итератор, бесконечно генерирующий единственное значение, переданное в качестве аргумента. Количество генераций можно ограничить с помощью необязательного аргумента `times`.

Аргументы функции:

- `obj` — любой Python объект
- `times` — количество повторений, по умолчанию имеет значение `None`

Приведенный ниже код:

```python
from itertools import repeat

for i in repeat('bee-and-geek', 5):
    print(i)

repeat_iter = repeat([1, 2, 3])

print(next(repeat_iter))
print(next(repeat_iter))
print(next(repeat_iter))
```

выводит:

```no-highlight
bee-and-geek
bee-and-geek
bee-and-geek
bee-and-geek
bee-and-geek
[1, 2, 3]
[1, 2, 3]
[1, 2, 3]
```


Функцию `repeat()` удобно использовать совместно c функциями `zip()` и `map()`, если со значениями, генерируемыми другими итераторами, должно сочетаться некое постоянное значение.

Приведенный ниже код объединяет значения `0, 1, 2, 3, 4, ...` со строкой `bee-and-geek`, возвращаемой функцией `repeat()`:

```python
from itertools import count, repeat

for i, s in zip(count(), repeat('bee-and-geek', 5)):
    print(i, s)
```

и выводит: 

```no-highlight
0 bee-and-geek
1 bee-and-geek
2 bee-and-geek
3 bee-and-geek
4 bee-and-geek
```

### Функция starmap()

Функция `starmap()` возвращает итератор, элементами которого являются элементы переданного итерируемого объекта `iterable`, к которым была применена функция `func`.

Аргументы функции:

- `func` — произвольная функция
- `iterable` — итерируемый объект, элементами которого являются итерируемые объекты

Приведенный ниже код:

```python
from itertools import starmap

persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]
pairs = [(1, 3), (2, 5), (6, 4)]
points = [(1, 1, 1), (1, 1, 2), (2, 2, 3)]

full_names = list(starmap(lambda name, surname: f'{name} {surname}', persons))

print(full_names)
print(*starmap(lambda a, b: a + b, pairs))
print(*starmap(lambda x, y, z: x * y * z, points))
```

выводит:

```no-highlight
['Timur Guev', 'Arthur Kharisov']
4 7 10
1 2 12
```

### Функция accumulate()

Функция `accumulate()` возвращает итератор, элементами которого являются накопленные суммы или накопленные результаты функции `func`.

Аргументы функции:

- `iterable` — итерируемый объект
- `func` — функция, принимающая два аргумента, по умолчанию используется функция сложения `operator.add`
- `initial` — начальное значение, по умолчанию имеет значение `None`

Функция работает аналогично функции `reduce()` за тем исключением, что функция `accumulate()` генерирует все промежуточные результаты, а не только конечный.

Приведенный ниже код:

```python
from itertools import accumulate
import operator

data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]

print(list(accumulate(data)))
print(list(accumulate(data, operator.mul)))
print(list(accumulate(data, max)))
print(list(accumulate(data, min)))
```

выводит:

```no-highlight
[3, 7, 13, 15, 16, 25, 25, 32, 37, 45]
[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]
[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]
[3, 3, 3, 2, 1, 1, 0, 0, 0, 0]
```




## Функции, фильтрующие данные

К этой категории относятся следующие функции:

- dropwhile()
- takewhile()
- filterfalse()
- compress()
- islice()

### Функция dropwhile()

Функция `dropwhile()` возвращает итератор, который генерирует элементы из входного итерируемого объекта сразу же после того, как для заданного условия будет получено ложное значение.

Приведенный ниже код:

```python
from itertools import dropwhile

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(dropwhile(lambda num: num <= 5, numbers))
print(new_numbers)

for word in dropwhile(lambda s: len(s) == 2, words):
    print(word)
```

выводит:

```no-highlight
[6, 7, 8, 9, 10, 1, 2, 3]
python
C#
beegeek
is
```

### Функция takewhile()

Функция `takewhile()` возвращает итератор, который генерирует элементы из входного итерируемого объекта до тех пор пока для заданного условия не будет получено ложное значение. По сути, действия функции `takewhile()` противоположны действиям функции `dropwhile()`.

Аргументы функции:

- `predicate` — фильтрующая функция, возвращающая `bool` значение
- `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import takewhile

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(takewhile(lambda num: num <= 5, numbers))
print(new_numbers)

for word in takewhile(lambda s: len(s) == 2, words):
    print(word)
```

выводит:

```no-highlight
[1, 1, 2, 3, 4, 4, 5]
is
an
of
```

Если требуется обеспечить более сложную логику фильтрации, то вместо использования лямбда функции нужно определить функцию явно.

### Функция filterfalse()

Функция `filterfalse()` возвращает итератор, который генерирует элементы из входного итерируемого объекта для которых заданное условие ложно. По сути, действия функции `filterfalse()` противоположны действиям встроенной функции `filter()`.

Аргументы функции:

- `predicate` — фильтрующая функция, возвращающая `bool` значение
- `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import filterfalse

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(filterfalse(lambda num: num <= 5, numbers))
print(new_numbers)

for word in filterfalse(lambda s: len(s) == 2, words):
    print(word)
```

выводит:

```no-highlight
[6, 7, 8, 9, 10]
python
beegeek
```

### Функция compress()

Функция `compress()` предлагает другой способ фильтрации содержимого итерируемого объекта. Вместо того чтобы вызывать функцию, она использует значения другого итерируемого объекта для индикации того, следует ли принять значение или игнорировать его.

Аргументы функции:

- `iterable` — итерируемый объект
- `selectors` — итерируемый объект, состоящий из значений `True, False`, который предоставляет значения, указывающие на то, какие входные значения следует брать, а какие следует игнорировать

Приведенный ниже код:

```python
from itertools import compress

data = 'ABCDEF'
selectors = [True, False, True, False, True, False]

result = compress(data, selectors)
print(list(result))
```

Обратите внимание на то, что функция `compress()` останавливается, когда исчерпан любой из итерируемых объектов `iterable` или `selectors`.

### Функция islice()

Функция `islice()` возвращает итератор, который генерирует последовательность из выбранных элементов переданного итерируемого объекта. Другими словами, функция `islice()` позволяет получить срез итерируемого объекта, для которого не всегда можно получить срез обычными средствами.

Аргументы функции:

- `iterable` — итерируемый объект
- `start` — начало среза, по умолчанию имеет значение 00
- `stop` — конец среза (не включительно)
- `step` — шаг среза, по умолчанию имеет значение 11

По сути, функция `islice()` имеет те же аргументы, что и оператор взятия среза списка: `start`, `stop` и `step`. При этом аргументы `start` и `step` — необязательные. Таким образом, вызывать функцию `islice()` можно одним из трех способов:

```python
islice(iterable, stop)
islice(iterable, start, stop)
islice(iterable, start, stop, step)
```

при этом, если `stop` равен `None`, срез берется до конца.

Приведенный ниже код:

```python
from itertools import islice

print(*islice(range(10), None))
print(*islice(range(100), 5))
print(*islice(range(100), 5, 10))
print(*islice(range(100), 0, 100, 10))
```

выводит:

```no-highlight
0 1 2 3 4 5 6 7 8 9
0 1 2 3 4
5 6 7 8 9
0 10 20 30 40 50 60 70 80 90
```

## Функции, объединяющие и разделяющие данные

К этой категории относятся следующие функции:

- chain()
- chain.from_iterable()
- zip_longest()
- tee()

### Функция chain()

Функция `chain()` возвращает итератор, который последовательно генерирует элементы всех переданных итерируемых объектов.

Аргументы функции:

- `*iterables` — итерируемые объекты

Приведенный ниже код:

```python
from itertools import chain

chain_iter1 = chain('ABC', 'DEF')
print(*chain_iter1)

chain_iter2 = chain(enumerate('ABC'))
print(*chain_iter2)

for i in chain([1, 2, 3], ['a', 'b', 'c'], ('Timur', 29, 'Male', 'Teacher')):
    print(i, end=' ')
```

выводит:

```no-highlight
A B C D E F
(0, 'A') (1, 'B') (2, 'C')
1 2 3 a b c Timur 29 Male Teacher
```


### Функция chain.from_iterable()

Функция `chain.from_iterable()` принимает в качестве аргумента итерируемый объект, содержащий другие итерируемые объекты и возвращает итератор, который генерирует элементы всех вложенных итерируемых объектов.

Аргументы функции:

- `iterable` — итерируемый объект, содержащий другие итерируемые объекты

Приведенный ниже код:

```python
from itertools import chain

chain_iter1 = chain.from_iterable(['ABC', 'DEF'])      # передаем список
print(*chain_iter1)

chain_iter2 = chain.from_iterable(enumerate('ABC'))
print(*chain_iter2)

for i in chain.from_iterable(['Timur', '29', 'Male', 'Teacher']):
    print(i, end=' ')
```

выводит:

```no-highlight
A B C D E F
0 A 1 B 2 C
T i m u r 2 9 M a l e T e a c h e r 
```

Обратите внимание на то, что все вложенные в `iterable` объекты должны быть итерируемыми.

### Функция zip_longest()

Как мы уже знаем, встроенная функция `zip()` возвращает итератор, объединяющий элементы нескольких итерируемых объектов в кортежи. При этом функция `zip()` прекращает работу, как только исчерпывается самый короткий итерируемый объект. Чтобы обеспечить обработку всех входных элементов, когда итерируемые объекты имеют разные длины, используется функция `zip_longest()`.

Аргументы функции:

- `*iterables` — итерируемые объекты
- `fillvalue` — заполнитель, по умолчанию имеет значение `None`

Приведенный ниже код:

```python
from itertools import zip_longest

print(*zip([1, 2, 3], ['a', 'b', 'c', 'd', 'e']))
print(*zip_longest([1, 2, 3], ['a', 'b', 'c', 'd', 'e']))                     # fillvalue=None
print(*zip_longest([1, 2, 3], ['a', 'b', 'c', 'd', 'e'], fillvalue='*'))
print(*zip_longest(['a', 'b', 'c', 'd', 'e'], [1, 2, 3], fillvalue=777))
```

выводит:

```python
(1, 'a') (2, 'b') (3, 'c')
(1, 'a') (2, 'b') (3, 'c') (None, 'd') (None, 'e')
(1, 'a') (2, 'b') (3, 'c') ('*', 'd') ('*', 'e')
('a', 1) ('b', 2) ('c', 3) ('d', 777) ('e', 777)
```

### Функция tee()

Функция `tee()` позволяет создать несколько **независимых итераторов** на основе одного и того же итерируемого объекта.

Аргументы функции:

- `iterable` — итерируемый объект
- `n` — количество создаваемых итераторов, по умолчанию имеет значение 2

Итераторы, возвращаемые функцией `tee()`, могут быть использованы c целью передачи одного и того же набора данных нескольким алгоритмам для их параллельной обработки.

Приведенный ниже код:

```python
from itertools import tee

iter1, iter2 = tee([1, 'a', 2, 'b', 3, 'c'])    # по умолчанию n=2

print(*iter1)
print(*iter2)
```

выводит:

```no-highlight
1 a 2 b 3 c
1 a 2 b 3 c
```

Новые итераторы, созданные функцией `tee()`, разделяют данные c исходным итерируемым объектом, и поэтому после их создания исходный итерируемый объект не должен изменяться.

### Функция pairwise()

Функция `pairwise()` возвращает итератор, содержащий последовательные перекрывающиеся пары в виде кортежей, взятые из исходного итерируемого объекта.

Аргументы функции:

- `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import pairwise

print(*pairwise('ABCDEFG'))
print(*pairwise([1, 2, 3, 4, 5]))
```

выводит:

```no-highlight
('A', 'B') ('B', 'C') ('C', 'D') ('D', 'E') ('E', 'F') ('F', 'G')
(1, 2) (2, 3) (3, 4) (4, 5)
```


